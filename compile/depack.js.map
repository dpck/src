{
"version":3,
"file":"compile/depack.js",
"lineCount":1441,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/@wrote/write/src/index.js","node_modules/makepromise/src/index.js","node_modules/path/index.js","node_modules/@wrote/ensure-path/src/index.js","node_modules/@wrote/read-dir-structure/src/index.js","node_modules/@wrote/rm/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/erte/src/index.js","node_modules/module/index.js","node_modules/resolve-dependency/src/index.js","node_modules/mismatch/src/index.js","node_modules/@depack/detect/src/index.js","node_modules/@depack/split/src/index.js","node_modules/fpj/src/index.js","node_modules/static-analysis/src/lib.js","node_modules/static-analysis/src/index.js","node_modules/paddys/src/index.js","node_modules/frame-of-mind/src/index.js","src/lib/index.js","src/lib/closure.js","node_modules/indicatrix/src/index.js","src/lib/run.js","node_modules/child_process/index.js","node_modules/spawncommand/src/index.js","src/lib/compile.js","node_modules/vm/index.js","node_modules/@a-la/detect-jsx/src/lib/index.js","node_modules/@a-la/detect-jsx/src/index.js","node_modules/restream/src/lib/index.js","node_modules/restream/src/SyncReplaceable.js","node_modules/restream/src/lib/markers.js","node_modules/restream/src/Replaceable.js","node_modules/@a-la/jsx/src/lib/index.js","node_modules/@a-la/jsx/src/lib/extract.js","node_modules/@a-la/jsx/src/lib/parse-content.js","node_modules/@a-la/jsx/src/lib/components.js","node_modules/@a-la/jsx/src/index.js","node_modules/@depack/bundle/src/lib/BundleTransform.js","node_modules/@depack/bundle/src/lib/lib.js","node_modules/@depack/bundle/src/lib/index.js","node_modules/@depack/bundle/src/index.js","src/lib/bundle.js","src/lib/chunks.js","src/index.js","src/depack.js","src/lib/get-options.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import { mkdir, mkdirSync } from 'fs'\nimport makePromise from 'makepromise'\nimport { dirname } from 'path'\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport default async function ensurePath(path) {\n  const dir = dirname(path)\n  try {\n    await make(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nasync function make(dir) {\n  try {\n    await makePromise(mkdir, dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      await make(parentDir)\n      await make(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to synchronously, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport function ensurePathSync(path) {\n  const dir = dirname(path)\n  try {\n    makeSync(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nfunction makeSync(dir) {\n  try {\n    mkdirSync(dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      makeSync(parentDir)\n      makeSync(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}","import { lstat, readdir } from 'fs'\nimport makePromise from 'makepromise'\nimport { join, relative } from 'path'\n\n/**\n * Update information about directory's content with lstat.\n * @param {string} dirPath Path to the root directory\n * @param {!Array<string>} dirContent\n * @returns {!Promise<!Array<!_wrote.File>>} An array with file objects.\n */\nasync function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}\n\n/**\n * Check if lstat result is a directory\n * @param {!_wrote.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is a directory\n */\nconst isDirectory = lstatRes => lstatRes.lstat.isDirectory()\n/**\n * Check if lstat result is not a directory\n * @param {!_wrote.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is not a directory\n */\nconst isNotDirectory = lstatRes => !lstatRes.lstat.isDirectory()\n\nconst getType = (lstatRes) => {\n  if (lstatRes.lstat.isDirectory()) {\n    return 'Directory'\n  }\n  if (lstatRes.lstat.isFile()) {\n    return 'File'\n  }\n  if (lstatRes.lstat.isSymbolicLink()) {\n    return 'SymbolicLink'\n  }\n}\n\n/**\n * Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n * @param {string} dirPath Path to the directory.\n * @param {!_wrote.ReadDirStructureOpts} [opts] Options for reading the dir structure.\n * @param {!Array<string>} [opts.ignore] The list of paths inside of the directory to ignore, e.g., `[.git]`.\n * @returns {!Promise<!_wrote.DirectoryStructure>} An object reflecting the directory structure.\n * @example\n  ```js\n  const res = await readDirStructure('dir')\n  // result:\n  {\n    type: 'Directory',\n    content: {\n      'data.txt': {\n        type: 'File'\n      },\n      subdir: {\n        type: 'Directory',\n        content: {\n          'data-ln.txt': {\n            type: 'SymbolicLink'\n          },\n        }\n      }\n    }\n  }\n  ```\n */\nexport default async function readDirStructure(dirPath, opts = {}) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const { ignore = [] } = opts\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const rel = relative(dirPath, path)\n    if (ignore.includes(rel)) return acc\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}\n\n/**\n * After running the `readDirStructure`, this function can be used to flatten the `content` output and return the list of all files (not including symlinks).\n * @param {!_wrote.Content} content The recursive content of the directory.\n * @param {string} path The path to the directory.\n */\nexport const getFiles = (content, path) => {\n  let files = []\n  let dirs = []\n  Object.keys(content).forEach((key) => {\n    const { type } = content[key]\n    if (type == 'File') files.push(join(path, key))\n    else if (type == 'Directory') dirs.push(key)\n  })\n  const dirFiles = dirs.reduce((acc, dir) => {\n    const { content: c } =\n      /** @type {!_wrote.Content} */ (content[dir])\n    const f = getFiles(c, join(path, dir))\n    return [...acc, ...f]\n  }, [])\n  return [...files, ...dirFiles]\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Content} _wrote.Content\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').ReadDirStructureOpts} _wrote.ReadDirStructureOpts\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').DirectoryStructure} _wrote.DirectoryStructure\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').File} _wrote.File\n */","import { unlink, rmdir, lstat } from 'fs'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport makePromise from 'makepromise'\nimport { join } from 'path'\n\nconst removeFile = async (path) => {\n  await makePromise(unlink, path)\n}\n\n/**\n * Removes files and directories.\n * @param {string} path Path to remove.\n */\nconst removeDir = async (path) => {\n  const { content } = await readDirStructure(path)\n  const files = Object.keys(/** @type {!Object} */ (content))\n    .filter((k) => {\n      const { type } = content[k]\n      if (type == 'File' || type == 'SymbolicLink') return true\n    })\n  const dirs = Object.keys(/** @type {!Object} */ (content))\n    .filter((k) => {\n      const { type } = content[k]\n      if (type == 'Directory') return true\n    })\n  const filesFullPaths = files.map(file => join(path, file))\n  await Promise.all(\n    filesFullPaths.map(removeFile)\n  )\n  const dirsFullPaths = dirs.map(dir => join(path, dir))\n  await Promise.all(\n    dirsFullPaths.map(removeDir)\n  )\n  await makePromise(rmdir, path)\n}\n\n/**\n * Removes a path from the filesystem.\n * @param {string} path Path to the file or directory to remove.\n */\nconst rm = async (path) => {\n  const s = /** @type {!fs.Stats} */ (\n    await makePromise(lstat, path)\n  )\n  if (s.isDirectory()) {\n    await removeDir(path)\n  } else {\n    await removeFile(path)\n  }\n}\n\nexport default rm\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */\n\n/* documentary types/index.xml */\n","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","export default _module\nexport const {\n  Module,\n  builtinModules,\n  runMain,\n  wrap,\n} = _module","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","import mismatch from 'mismatch'\n\nconst RE = /^ *import(?:\\s+(?:[^\\s,]+)\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE2 = /^ *import\\s+(?:.+?\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE3 = /^ *import\\s+(['\"])(.+?)\\1/gm\nconst RE4 = /^ *export\\s+(?:{[^}]+?}|\\*)\\s+from\\s+(['\"])(.+?)\\1/gm\n\n/**\n * Returns the names of the modules imported with `import` and `export` statements.\n * @param {string} source The source to detect matches in.\n */\nconst getMatches = (source) => {\n  const res = [RE, RE2, RE3, RE4].reduce((acc, re) => {\n    const m = mismatch(re, source, ['q', 'from'])\n      .map(a => a['from'])\n    return [...acc, ...m]\n  }, [])\n  return res\n}\n\nexport default getMatches\n\nexport const RES = {\n  RE, RE2, RE3, RE4,\n}","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","import { join, relative, resolve, dirname } from 'path'\nimport exists from '@wrote/exists'\nimport read from '@wrote/read'\nimport resolveDep from 'resolve-dependency'\n\n/**\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\n * @param {string} dir The path to the directory where the requiring file is located.\n * @param {string} name The name of the required package.\n * @param {!_fpj.Config} opts The options for `fpj`.\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n * @returns {!Promise<!_fpj.Return>}\n */\nconst findPackageJson = async (dir, name, opts = {}) => {\n  const { fields, soft = false } = opts\n  const fold = join(dir, 'node_modules', name)\n  const path = join(fold, 'package.json')\n  const e = await exists(path)\n  if (e) {\n    const res = await findEntry(path, fields)\n    if (res === undefined)\n      throw new Error(`The package ${relative('', path)} does export the module.`)\n    else if (!res.entryExists && !soft)\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\n    const { entry, version, packageName, main, entryExists, ...rest } = res\n    const result = /** @type {!_fpj.Return} */ ({\n      entry: relative('', entry),\n      packageJson: relative('', path),\n      ...(version ? { version } : {}),\n      packageName,\n      ...(main ? { hasMain: true } : {}),\n      ...(!entryExists ? { entryExists: false } : {}),\n      ...rest,\n    })\n    return result\n  }\n  if (dir == '/' && !e)\n    throw new Error(`Package.json for module ${name} not found.`)\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\n}\n\n/**\n * Finds the path to the entry based on package.json file.\n * @param {string} path\n * @param {!Array<string>} fields\n */\nexport const findEntry = async (path, fields = []) => {\n  const f = await read(path)\n  let mod, version, packageName, main, rest\n  try {\n    ({\n      'module': mod,\n      'version': version,\n      'name': packageName,\n      'main': main,\n      ...rest\n    } = JSON.parse(f))\n    rest = fields.reduce((acc, current) => {\n      acc[current] = rest[current]\n      return acc\n    }, {})\n  } catch (err) {\n    throw new Error(`Could not parse ${path}.`)\n  }\n  const dir = dirname(path)\n  let resolved = mod || main\n  if (!resolved) {\n    const indexExists = await exists(join(dir, 'index.js'))\n    if (!indexExists) return undefined\n    resolved = main = 'index.js'\n  }\n  let entry = join(dir, resolved)\n  let r\n  try {\n    ({ path: r } = await resolveDep(entry))\n    entry = r\n  } catch (err) {/* does not exist */}\n  return { entry, version, packageName, main: !mod && main,\n    entryExists: !!r,\n    ...rest }\n}\n\nexport default findPackageJson\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Config} Config The options for `fpj`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Config The options for `fpj`.\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Return} Return The return type of the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Return The return type of the program.\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\n * @prop {string} packageJson The path to the package.json file itself.\n * @prop {string} packageName The name of the resolved package.\n * @prop {string} [version] The version of the package.\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\n */\n","import { dirname, join } from 'path'\nimport { builtinModules } from 'module'\nimport read from '@wrote/read'\nimport resolveDependency from 'resolve-dependency'\nimport getMatches from '@depack/detect'\nimport split from '@depack/split'\nimport findPackageJson from 'fpj'\nimport mismatch from 'mismatch'\nimport erotic from 'erotic'\n\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\n/**\n * Expands the dependency match to include `package.json` and entry paths.\n * @param {string} path The path to the file.\n * @param {!Array<string>} matches The matches.\n * @param {boolean} [soft] Whether to throw when a dependency's package.json is not found.\n * @param {!Array<string>} [fields] What additional fields to fetch from package.json.\n * @returns {!Promise<!Array<!_staticAnalysis.DependencyMeta>>}\n */\nconst getDependenciesMeta = async (path, matches, soft, fields, pckg = null) => {\n  const e = erotic()\n  const dir = dirname(path)\n  const proms = matches.map(async (name) => {\n    const internal = builtinModules.includes(name)\n    if (internal) return { internal: name }\n    const isLib = checkIfLib(name)\n    if (isLib) {\n      try {\n        const { path: entry } = await resolveDependency(name, path)\n        return { entry, package: pckg }\n      } catch (err) { /*\n        maybe a local package with package.json\n      */}\n    } else {\n      const { name: n, paths } = split(name)\n      if (paths) {\n        const { packageJson, packageName } = await findPackageJson(dir, n)\n        const d = dirname(packageJson)\n        const { path: entry } = await resolveDependency(join(d, paths))\n        return { entry, package: packageName }\n      }\n    }\n    try {\n      const {\n        entry, packageJson, version, packageName, hasMain, ...rest\n      } = await findPackageJson(dir, name, { fields })\n      if (packageName == pckg) {\n        console.warn('[static-analysis] Skipping package %s that imports itself in %s', packageName, path)\n        return null\n      }\n      return {\n        entry, packageJson, version, name: packageName,\n        ...(hasMain ? { hasMain } : {}),\n        ...rest }\n    } catch (err) {\n      if (soft) return null\n      throw e(err)\n    }\n  })\n  return (await Promise.all(proms)).filter(Boolean)\n}\n\n/**\n * Detects the imports.\n * @param {string} path\n * @param {Object} cache\n * @returns {!Promise<!Array<!_staticAnalysis.Detection>>}\n */\nexport const detect = async (path, cache = {}, {\n  nodeModules = true, shallow = false, soft = false, fields = [],\n  node_modules_cache = {},\n  mergeSameNodeModules = true,\n  package: pckg } = {}) => {\n  if (path in cache) return []\n  cache[path] = 1\n  const source = await read(path)\n  const matches = getMatches(source)\n  const requireMatches = getRequireMatches(source)\n  const fm = nodeModules ? matches : matches.filter(checkIfLib)\n  const fr = nodeModules ? requireMatches : requireMatches.filter(checkIfLib)\n\n  let deps\n  try {\n    const dm = await getDependenciesMeta(path, fm, soft, fields, pckg)\n    const rm = await getDependenciesMeta(path, fr, soft, fields, pckg)\n    rm.forEach((val) => {\n      val.required = true\n    })\n    deps = [...dm, ...rm]\n  } catch (err) {\n    err.message = `${path}\\n [!] ${err.message}`\n    throw err\n  }\n  const Deps = mergeSameNodeModules ? deps.map(o => {\n    const { name, version, required } = o\n    if (name && version) {\n      // for non-flattened node_modules structure, e.g., when linking\n      // to prevent multiple same packages like\n      // depA, node_modules/depB/node_modules/depA\n      const n = `${name}:${version}${required ? '-required' : ''}`\n      const existing = node_modules_cache[n]\n      if (existing) return existing\n\n      node_modules_cache[n] = o\n    }\n    return o\n  }) : deps\n  const d = Deps.map(o => ({ ...o, from: path }))\n  const entries = Deps\n    .filter(({ entry }) => {\n      return entry && !(entry in cache)\n    })\n  const discovered = await entries\n    .reduce(async (acc, {\n      entry, hasMain, packageJson, name, package: p }) => {\n      if (packageJson && shallow) return acc\n      const accRes = await acc\n      const res = await detect(entry, cache, {\n        nodeModules, shallow, soft, fields, package: name || p,\n        node_modules_cache, mergeSameNodeModules,\n      })\n      const r = res\n        .map(o => ({\n          ...o,\n          from: o.from ? o.from : entry,\n          ...(!o.packageJson && hasMain ? { hasMain } : {}),\n        }))\n      return [...accRes, ...r]\n    }, d)\n  return discovered\n}\n\nexport const getRequireMatches = (source) => {\n  const m = mismatch(/(?:^|[^\\w\\d_])require\\(\\s*(['\"])(.+?)\\1\\s*\\)/gm, source, ['q', 'from'])\n  const res = m.map(a => a['from'])\n  return res\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Detection} _staticAnalysis.Detection\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').DependencyMeta} _staticAnalysis.DependencyMeta\n */","import resolveDependency from 'resolve-dependency'\nimport erotic from 'erotic'\nimport { detect } from './lib'\n\n/**\n * Detects all dependencies in a file and their dependencies recursively.\n * @param {!Array<string>|string} path The path to the file in which to detect dependencies.\n * @param {!_staticAnalysis.Config} [config] The configuration options for `staticAnalysis`.\n * @return {!Promise<!Array<_staticAnalysis.Detection>>}\n */\nconst staticAnalysis = async (path, config = {}) => {\n  const e = erotic()\n  let paths = Array.isArray(path) ? path : [path]\n  paths = await Promise.all(paths.map(async p => {\n    const { path: pp } = await resolveDependency(p)\n    return pp\n  }))\n\n  const {\n    nodeModules = true,\n    shallow = false,\n    soft = false,\n    fields = [],\n    mergeSameNodeModules = true,\n  } = config\n  let detected\n  try {\n    const cache = {}\n\n    detected = await paths.reduce(async (acc, p) => {\n      acc = await acc\n      const res = await detect(p, cache, {\n        nodeModules, shallow, soft, fields, mergeSameNodeModules })\n      acc.push(...res)\n      return acc\n    }, [])\n  } catch (err) {\n    throw e(err)\n  }\n  const filtered = detected.filter(({ internal, entry }, i) => {\n    if (internal) {\n      const fi = detected.findIndex(({ internal: ii }) => {\n        return ii == internal\n      })\n      return fi == i\n    }\n    const ei = detected.findIndex(({ entry: ee }) => {\n      return entry == ee\n    })\n    return ei == i\n  })\n  const f = filtered.map((ff) => {\n    const { entry, internal } = ff\n    const froms = detected\n      .filter(({ internal: i, entry: ee }) => {\n        if (internal) return internal == i\n        if (entry) return entry == ee\n      })\n      .map(({ from }) => from)\n      .filter((el, i, a) => a.indexOf(el) == i)\n    const newF =  { ...ff, from: froms }\n    return newF\n  })\n    .map(({ package: pckg, ...props }) => {\n      if (pckg) return { package: pckg, ...props }\n      return props\n    })\n  return f\n}\n\n/**\n * Sorts the detected dependencies into commonJS modules, packageJsons and internals.\n * @param {!Array<!_staticAnalysis.Detection>} detected The detected matches\n * @return {_staticAnalysis.SortReturn}\n */\nexport const sort = (detected) => {\n  const packageJsons = []\n  const commonJsPackageJsons = []\n  const commonJs = []\n  const js = []\n  const internals = []\n  const deps = []\n  detected\n    .forEach(({ packageJson, hasMain, name, entry, internal }) => {\n      if (internal) return internals.push(internal)\n\n      if (packageJson && hasMain)\n        commonJsPackageJsons.push(packageJson)\n      else if (packageJson) packageJsons.push(packageJson)\n      if (entry && hasMain) commonJs.push(entry)\n      else if (entry) js.push(entry)\n      if (name) deps.push(name)\n    })\n  return { commonJsPackageJsons,\n    packageJsons, commonJs, js, internals, deps }\n}\n\nexport default staticAnalysis\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Config} _staticAnalysis.Config\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').SortReturn} _staticAnalysis.SortReturn\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Detection} _staticAnalysis.Detection\n */","/**\n * Pad Strings.\n * @param {number} width The width to which to pad.\n * @param {string} string The string to pad.\n */\nconst pad = (width, string) => {\n  const d = Math.max(width - string.length, 0)\n  const p = ' '.repeat(d)\n  const s = `${string}${p}`\n  return s\n}\n\n/**\n * Pads the string so that each line is of equal width.\n * @param {string} string The string to pad.\n * @param {!_paddys.Config} [options] Options for the program.\n * @param {number} [options.width] The width to which to pad lines.\n * @example\n```\nconst res = paddys(`test\nt`)\n// test\n// t___\n```\n */\nconst paddys = (string, options = {}) => {\n  const {\n    width,\n  } = options\n  const s = string.split('\\n')\n  const w = width || s.reduce((acc, { length: l }) => l > acc ? l : acc, 0)\n  return s.map(pad.bind(null, w)).join('\\n')\n}\n\nexport default paddys\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_paddys.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _paddys.Config Options for the program.\n * @prop {number} [width] The width to which to pad lines.\n */\n","import paddys from 'paddys'\n/**\n * Add a frame around strings.\n * @param {string} string The string to frame.\n * @param {!_frameOfMind.Config} [options] Options for the program.\n * @param {number} [options.padding=1] The left and right padding. Default `1`.\n */\nexport default function frameOfMind(string, options = {}) {\n  const { padding = 1 } = options\n  const l = string.split('\\n')\n  const w = l.reduce((acc, { length }) => length > acc ? length : acc, 0)\n  const ww = w + padding * 2\n  const bt = `\u250c${'\u2500'.repeat(ww)}\u2510`\n  const bb = `\u2514${'\u2500'.repeat(ww)}\u2518`\n  const pp = ' '.repeat(padding)\n  const p = paddys(string)\n    .split('\\n')\n    .map(line => `\u2502${pp}${line}${pp}\u2502`)\n    .join('\\n')\n  return `${bt}\\n${p}\\n${bb}`\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_frameOfMind.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _frameOfMind.Config Options for the program.\n * @prop {number} [padding=1] The left and right padding. Default `1`.\n */\n","import { c, b } from 'erte'\nimport { join, dirname, basename, relative } from 'path'\nimport { write, read, exists } from '@wrote/wrote'\nimport { builtinModules } from 'module'\n\nexport const replaceWithColor = (str, name, color, background = false) => {\n  const re = new RegExp(`--${name} (\\\\\\\\\\n)?(\\\\S+)`, 'g')\n  return str.replace(re, (m, bef, f) => {\n    const fn = background ? b : c\n    return `--${name} ${bef || ''}${fn(f, color)}`\n  })\n}\n\n/**\n * Returns the pretty-printed command for the bundler.\n * @param {!Array<string>} args The array with arguments.\n * @param {!Array<string>} js The list of js files and chunks.\n */\nexport const getCommand = (args, js) => {\n  let s = getShellCommand(args)\n\n  s = replaceWithColor(s, 'compilation_level', 'green', true)\n  s = replaceWithColor(s, 'js_output_file', 'red')\n\n  const sep = '\\n     '\n  const jss = js.filter(a => a != '--js').map((file, i, a) => {\n    if (file == '--chunk') {\n      return `${file} `\n      // return `${c(file, 'magenta')} `\n    } else if (a[i-1] == '--chunk') {\n      return `${c(file, 'magenta')}${sep}`\n    }\n    let j = `${c(file, 'green')}`\n    if (a.length - 1 == i) return j\n    if (a[i + 1] == '--chunk') return `${j}\\n`\n    //${(a.length - 1 != i && a[i + 1] != '--chunk') ? sep : ''}`\n    return `${j}${sep}`\n  }).join('')\n  // .join('\\n     ')\n  return `${s}\\n--js ${jss}`.trim()\n}\n\nexport const addData = async (path, { sourceMap }) => {\n  const r = await read(path)\n  const rr = [r]\n  if (sourceMap) {\n    const name = basename(path)\n    rr.push('//' + `# sourceMappingURL=${name}.map`)\n  }\n  await write(path, rr.join('\\n'))\n}\n\nexport const removeStrict = async (path, wrapper = '', noStrict = false) => {\n  // if we compiled a library, GCC would already not have use strict\n  // as compared to the compile mode where we added #!/usr/bin/env node\n  // on top which resulted in an extra 'use strict' after the wrapper\n  if (wrapper.startsWith('\\'use strict\\'') && !noStrict) return\n  const r = await read(path)\n  const prepared = prepareOutput(r, wrapper, noStrict)\n  await write(path, prepared)\n}\n\n// fixes 'use strict' to be on top\nexport const prepareOutput = (output, wrapper = '', noStrict = false) => {\n  const wp = wrapper.replace(/%output%$/, '')\n  const actualOutput = output.replace(wp, '')\n  const hasUseStrict = actualOutput.startsWith('\\'use strict\\';')\n  let ao = actualOutput\n  if (wrapper || noStrict)\n    ao = actualOutput.replace(/'use strict';/, ' '.repeat(13))\n  const aw = noStrict || !hasUseStrict ? wp.replace(/'use strict';/, ' '.repeat(13)) : wp\n  return `${aw}${ao}`\n}\n\nexport const updateSourceMaps = async (path, tempDir) => {\n  const map = `${path}.map`\n  const r = await read(map)\n  const j = JSON.parse(r)\n  const { 'sources': sources } = j\n  const newSources = sources.map(s => {\n    if (s.startsWith(' ')) return s\n    return `/${relative(tempDir, s)}`\n  })\n  j['sources'] = newSources\n  const jj = JSON.stringify(j, null, 2)\n  await write(map, jj)\n}\n\n/**\n * Returns whether the dependency is a library from the package.\n * @param {string} modName\n * @example\n * checkIfLib('./lib') // true\n * checkIfLib('preact') // false\n */\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\n/**\n * Gets the wrapper to for the output to enable requiring Node.js modules.\n * @param {!Array<string>} internals The list of internal modules used in the program.\n * @example\n * const fs = require('fs');\n * const _module = require('module');\n */\nexport const getWrapper = (internals) => {\n  if (!internals.length) return\n  const wrapper = internals\n    .map(i => {\n      let m = i\n      if (['module', 'process', 'console', 'crypto'].includes(i)) m = `_${i}`\n      return `const ${m} = r` + `equire('${i}');` // prevent\n    })\n    .join('\\n') + '%output%'\n  return `#!/usr/bin/env node\n'use strict';\n${wrapper}`\n}\n\n/**\n * Checks whether static analysis returned .json files.\n * @param {!Array<!_staticAnalysis.Detection>} detected\n */\nexport const hasJsonFiles = detected => detected.filter(({ entry }) => {\n  if (entry)\n    return entry.endsWith('.json')\n})\n\nconst { DEPACK_MAX_COLUMNS = 87 } = process.env\n\nexport const getShellCommand = (args, program = 'java') => {\n  const maxLength = process.stderr.columns - 3 || DEPACK_MAX_COLUMNS\n  let lastLineLength = program.length\n  const s = args.reduce((acc, current) => {\n    if (lastLineLength + current.length > maxLength) {\n      acc = acc + ' \\\\\\n' + current\n      lastLineLength = current.length\n    } else {\n      acc = acc + ' ' + current\n      lastLineLength += current.length + 1\n    }\n    return acc\n  }, program)\n  return s\n}\n\n/**\n * @param {!Array<string>} files Paths to externs.\n * @param {string} [name] The package name.\n */\nexport const checkExternsExist = async (files, name) => {\n  await Promise.all(files.map(async pp => {\n    const exist = await exists(pp)\n    if (!exist) {\n      const n = name ? ` specified in the \"externs\" field of package ${name}` : ''\n      throw new Error(`Externs file ${pp}${n} doesn't exist.`)\n    }\n  }))\n}\n\n/**\n * Runs through detected packages and returns the list of externs specified in the `externs` field.\n * @param {!Array<!_staticAnalysis.Detection>} detected\n */\nexport const detectExterns = async (detected) => {\n  /** @type {!Array<string>} */\n  const nodeJS = []\n  /** @type {!Array<string>} */\n  const files = await detected.reduce(async (acc, { name, packageJson, 'externs': externs = [] }) => {\n    acc = await acc\n    if (!packageJson) return acc\n    const dir = dirname(packageJson)\n    externs = Array.isArray(externs) ? externs : [externs]\n    externs = externs.filter((e) => {\n      if (builtinModules.includes(e)) {\n        nodeJS.push(e)\n        return false\n      }\n      return true\n    })\n    const actual = externs.map((e) => join(dir, e))\n    await checkExternsExist(actual, name)\n    return [...acc, ...actual]\n  }, [])\n\n  return { files, nodeJS }\n}\n\nexport const createExternsArgs = (externs) => {\n  const args = externs.reduce((acc, e) => {\n    return [...acc, '--externs', e]\n  }, [])\n  return args\n}\n\nexport const unique = (e, i, a) => a.indexOf(e) == i\n\nexport const updateTempDirArgs = (args, tempDir) => {\n  return args.map((j) => {\n    return j.startsWith(tempDir) ? relative(tempDir, j) : j\n  })\n}\n\nexport const getBundleArgs = (compilerArgs, externs, output, noSourceMap, deps, processCommonJs) => {\n  const args = [\n    ...compilerArgs,\n    ...externs,\n    ...(output && !noSourceMap ? ['--source_map_include_content'] : []),\n    ...(deps.length > 1 ? ['--module_resolution', 'NODE'] : []),\n    ...(processCommonJs ? ['--process_common_js_modules'] : []),\n  ]\n  return args\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('static-analysis').Detection} _staticAnalysis.Detection\n */","import { c } from 'erte'\nimport { join, dirname, relative } from 'path'\nimport { ensurePath, write, read, exists } from '@wrote/wrote'\n// import getCorePath from '@depack/nodejs'\nimport resolveDependency from 'resolve-dependency'\n\n/**\n * Create an error with color.\n * @param {number} exitCode\n * @param {string} se The output of the compiler.\n */\nexport const makeError = (exitCode, se) => {\n  const r = se.split('\\n\\n')\n  const s = r.map((t) => {\n    const warn = /^.+?:\\d+:(?:\\s*Originally at:\\s*.+?)? WARNING -/.test(t)\n    if (warn) return c(t, 'grey')\n    return c(t, 'red')\n  }).join('\\n\\n')\n\n  const er = `Exit code ${exitCode}\\n${s}`\n  return er\n}\n\n\nconst getCoreVersion = () => {\n  let [VER] = process.version.split('.', 1)\n  const V = VER.replace(/[^\\d]/g, '')\n  if (V > 8 || V < 8) {\n    console.log('Your Node.JS version is %s but only externs for v8 are available at the moment. ' +\n      'This can result in compiler warnings.', VER)\n    VER = 'v8'\n  }\n  return VER\n}\n\n/**\n * Creates mocks in the `node_module` folder to serve as externs. It is not possible to serve proxies not from `node_modules` path because Closure does not understand it.\n * @param {!Object} opts\n * @param {!Array<string>} opts.internals The names of the core modules to prepare.\n * @param {string} [opts.nodeModulesPath] The path to the node_modules folder in which to put the core mocks. Default `node_modules`.\n * @param {boolean} [opts.force] Whether to force override. Default `true`.\n * @todo Add an option to dynamically evaluate the content of the mock.\n */\nexport const prepareCoreModules = async ({\n  internals, nodeModulesPath = 'node_modules', force = true,\n}) => {\n  const VER = getCoreVersion()\n  const getCorePath = require(/*ok depack*/'@depack/nodejs')\n  const corePath = getCorePath(VER)\n  const r = await Promise.all(internals.map(async (name) => {\n    const path = join(nodeModulesPath, name)\n    const packageJson = join(path, 'package.json')\n    const index = join(path, 'index.js')\n    const ret = { packageJson, index }\n\n    const e = await exists(packageJson)\n    if (e && !force) {\n      const depackExist = await testDepack(packageJson)\n      if (depackExist && depackExist == VER) return ret\n      else\n        throw new Error(`Could not prepare core module ${name}: ${path} exists.`)\n    }\n    await ensurePath(packageJson)\n    await write(packageJson, JSON.stringify({\n      'name': name, 'module': 'index.js', 'depack': VER,\n    }))\n    const core = await read(join(corePath, `${name}.js`))\n    await write(index, core)\n    return ret\n  }))\n  return r.reduce((acc, { packageJson, index }) => {\n    return [...acc, packageJson, index]\n  }, [])\n}\n\n/**\n * Check whether the package has the depack property meaning it is a mock and was created by `prepareCoreModules` earlier. Returns the version of Node when the core package was simulated in `node_modules`.\n */\nconst testDepack = async (packageJson) => {\n  try {\n    const testPackage = await read(packageJson)\n    const { 'depack': depack } = JSON.parse(testPackage)\n    return depack\n  } catch (err) { /* */ }\n}\n\n/**\n * Update dependencies' package.json files to point to a file and not a directory. * https://github.com/google/closure-compiler/issues/3149\n * @param {!Array<string>} commonJS The paths to CommonJS package.json files.\n * @param {!Array<string>} modules The paths to package.json files.\n */\nexport const fixDependencies = async (commonJS, modules) => {\n  const all = [...commonJS, ...modules]\n  await Promise.all(all.map(async (dep) => {\n    const dir = dirname(dep)\n    const f = await read(dep)\n    const p = JSON.parse(f)\n    const { 'main': main, 'module': mod } = p\n    const isModule = !!mod\n    const field = isModule ? 'module' : 'main'\n    let M = mod || main\n    if (!M) {\n      const j = join(dirname(dep), 'index.js')\n      const e = await exists(j)\n      if (!e) throw new Error(`Package ${dep} does not specify either main or module fields, and does not contain the index.js file.`)\n      p['main'] = 'index.js'\n      console.warn('Updating %s to have the main field.', dep)\n      await write(dep, JSON.stringify(p, null, 2))\n    }\n    let isDir, path\n    try {\n      ({ isDir, path } = await resolveDependency(M, dep))\n    } catch (err) {\n      throw new Error(`The ${field} for dependency ${dep} does not exist.`)\n    }\n    if (isDir) {\n      const newM = join(M, 'index.js')\n      p[field] = newM\n      console.warn('Updating %s to point to a file.', dep)\n      await write(dep, JSON.stringify(p, null, 2))\n    } else if (join(dir, p[field]) != path) {\n      const relPath = relative(dir, path)\n      p[field] = relPath\n      console.warn('Updating %s to point to the file with extension.', dep)\n      await write(dep, JSON.stringify(p, null, 2))\n    }\n  }))\n}","/**\n * @type {_indicatrix.indicatrix}\n */\nasync function $indicatrix(text, promise, options = {}) {\n  const { interval = 250, writable = process.stdout } = options\n  const p = typeof promise == 'function' ? promise() : promise\n  const write = writable.write.bind(writable)\n\n  const { INDICATRIX_PLACEHOLDER: placeholder } = process.env\n  if (placeholder && placeholder != '0') {\n    write(`${text}<INDICATRIX_PLACEHOLDER>`)\n    return await p\n  }\n\n  let i = 1\n  const getText = () => `${text}${'.'.repeat(i)}`\n  const clear = () => write(`\\r${' '.repeat(text.length + 3)}\\r`)\n  let s = getText()\n  write(s)\n  const int = setInterval(() => {\n    i = (i + 1) % 4\n    s = getText()\n    clear()\n    write(s)\n  }, interval)\n  try {\n    const res = await p\n    return res\n  } finally {\n    clearInterval(int)\n    clear()\n  }\n}\n\nexport default $indicatrix\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..')} _indicatrix.indicatrix\n */","import loading from 'indicatrix'\nimport spawn from 'spawncommand'\nimport { c } from 'erte'\nimport { createWriteStream } from 'fs'\nimport { makeError } from './closure'\nimport { addData } from './'\n\n/**\n * Spawns Java and executes the compilation.\n * @param {!Array<string>} args The arguments to Java.\n * @param {!_depack.RunConfig} [opts] General options for running of the compiler.\n * @param {string} [opts.output] The path where the output will be saved. Prints to `stdout` if not passed.\n * @param {string} [opts.debug] The name of the file where to save sources after each pass. Useful when there's a bug in GCC.\n * @param {string} [opts.compilerVersion] Used in the display message.\n * @param {boolean} [opts.noSourceMap=false] Disables source maps. Default `false`.\n * @return {!Promise<string>} Stdout of JavaProcess\n */\nconst run = async (args, opts = {}) => {\n  const {\n    debug, compilerVersion, output, noSourceMap, outputFiles,\n  } = opts\n  let { promise, stderr: compilerStderr } = spawn('java', args)\n  if (debug) compilerStderr.pipe(createWriteStream(debug))\n\n  const { stdout, stderr, code } = await loading(`Running Google Closure Compiler${\n    compilerVersion ? ' ' + c(compilerVersion, 'grey') : ''\n  }`, promise, {\n    writable: process.stderr,\n  })\n  // if(process.stderr.isTTY) process.stderr.write(' '.repeat(process.stderr.columns))\n\n  if (code) throw new Error(makeError(code, stderr))\n\n  if (!noSourceMap) {\n    if (outputFiles) {\n      await Promise.all(outputFiles.map(async (outputFile) => {\n        await addData(outputFile, { sourceMap: true })\n      }))\n    }\n    else if (output) await addData(output, { sourceMap: !noSourceMap })\n  }\n\n  if (stderr && !debug) console.warn(c(stderr, 'grey'))\n  else if (debug) console.log('Sources after each pass saved to %s', debug)\n  return stdout\n}\n\nexport default run\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_depack.RunConfig} RunConfig General options for running of the compiler.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _depack.RunConfig General options for running of the compiler.\n * @prop {string} [output] The path where the output will be saved. Prints to `stdout` if not passed.\n * @prop {string} [debug] The name of the file where to save sources after each pass. Useful when there's a bug in GCC.\n * @prop {string} [compilerVersion] Used in the display message.\n * @prop {boolean} [noSourceMap=false] Disables source maps. Default `false`.\n */\n","export default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process","import { spawn, fork as forkCp } from 'child_process'\nimport { collect } from 'catchment'\n\n/**\n * @param {!child_process.ChildProcess} proc\n * @returns {!Promise<_spawncommand.PromiseResult>}\n */\nconst getPromise = async (proc) => {\n  const [code, stdout, stderr] = await Promise.all([\n    new Promise((resolve, reject) => {\n      proc.on('error', reject)\n        .on('exit', (code) => {\n          resolve(code)\n        })\n    }),\n    proc.stdout ? collect(proc.stdout) : undefined,\n    proc.stderr ? collect(proc.stderr) : undefined,\n  ])\n  return {\n    code,\n    stdout,\n    stderr,\n  }\n}\n\n/**\n * Spawns a new process using the `command` and returns an instance of a ChildProcess, extended to have a `promise` property which is resolved when the process exits. The resolved value is an object with `stdout`, `stderr` and `code` properties.\n * @param {string} command The command to run.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.SpawnOptions} [options] Options used to spawn.\n */\nexport default function spawnCommand(command, args, options) {\n  if (!command) throw new Error('Please specify a command to spawn.')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (spawn(command, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/**\n * Forks a process and assign a `promise` property to it, resolved with `stderr`, `stdout` and `code` properties on exit.\n * @param {string} mod The module to run in the child.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.ForkOptions} [options] Options to fork the process with.\n */\nexport function fork(mod, args, options) {\n  if (!mod) throw new Error('Please specify a module to fork')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (forkCp(mod, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.PromiseResult} PromiseResult\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.PromiseResult\n * @prop {string} stdout The accumulated result of the `stdout` stream.\n * @prop {string} stderr The accumulated result of the `stderr` stream.\n * @prop {number} code The code with which the process exited.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').SpawnOptions} child_process.SpawnOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ChildProcess} child_process.ChildProcess\n */\n\n/* documentary types/cp.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.ChildProcessWithPromise} ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {child_process.ChildProcess & _spawncommand.$ChildProcessWithPromise} _spawncommand.ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.$ChildProcessWithPromise A child process with an extra `promise` property.\n * @prop {!Promise<!_spawncommand.PromiseResult>} promise A promise resolved when the process exits.\n * @prop {string} spawnCommand The spawn arguments joined by whitespace.\n */\n","/* eslint-disable no-console */\nimport { c } from 'erte'\nimport { join } from 'path'\nimport makePromise from 'makepromise'\nimport { chmod } from 'fs'\nimport { builtinModules } from 'module'\nimport detect, { sort } from 'static-analysis'\nimport frame from 'frame-of-mind'\nimport { removeStrict, getWrapper, hasJsonFiles, prepareOutput, getShellCommand, replaceWithColor, detectExterns, createExternsArgs, checkExternsExist } from './'\nimport { prepareCoreModules, fixDependencies } from './closure'\nimport run from './run'\n\n/**\n * Compile a Node.JS file into a single executable.\n * @param {!_depack.CompileConfig} options Options for the Node.JS package compiler.\n * @param {!_depack.RunConfig} [runOptions] General options for running of the compiler.\n * @param {!Array<string>} [compilerArgs] The compiler args got with `getOptions` and/or manually extended.\n */\nconst Compile = async (options, runOptions = {}, compilerArgs = []) => {\n  const { src, noStrict, verbose, silent } = options\n  const { output } = runOptions\n  if (!src) throw new Error('Source is not given.')\n  // allow to pass internals in --externs arg, e.g.,\n  // --externs stream\n  // this is when externs are needed but not imported in code\n  /** @type {!Array<string>} */\n  const foundAdditional = compilerArgs.reduce((acc, val, i, a) => {\n    if (val != '--externs') return acc\n    const next = a[i + 1]\n    if (!next) return acc\n    if (builtinModules.includes(next)) {\n      compilerArgs[i] = ''\n      compilerArgs[i + 1] = ''\n      acc.push(next)\n    }\n    return acc\n  }, [])\n  const realCompilerArgs =\n    foundAdditional.length ? compilerArgs.filter(a => a) : compilerArgs\n\n  const args = [\n    ...realCompilerArgs,\n    '--package_json_entry_names', 'module,main',\n    '--entry_point', src,\n  ]\n  const detected = await detect(src, {\n    fields: ['externs'],\n  })\n  const { files: detectedExterns, nodeJS } = await detectExterns(detected)\n  detectedExterns.length && console.error('%s %s', c('Modules\\' externs:', 'blue'), detectedExterns.join(' '))\n  const detectedExternsArgs = createExternsArgs(detectedExterns)\n  warnOfCommonJs(detected)\n\n  const sorted = sort(detected)\n  const {\n    commonJs, commonJsPackageJsons, internals, js, packageJsons,\n  } = sorted\n  const internalDeps = await prepareCoreModules({ internals })\n  const externs = await getNodeExterns(internals, [\n    ...foundAdditional,\n    ...nodeJS,\n  ])\n  await fixDependencies(commonJsPackageJsons, packageJsons)\n\n  const files = [src,\n    ...commonJsPackageJsons,\n    ...packageJsons,\n    ...js,\n    ...commonJs,\n    ...internalDeps,\n  ].sort((a, b) => {\n    if (a.startsWith('node_modules')) return -1\n    if (b.startsWith('node_modules')) return 1\n    return 0\n  })\n  const wrapper = getWrapper(internals)\n  const jsonFiles = hasJsonFiles(detected)\n\n  const Args = [\n    ...args,\n    ...externs,\n    ...detectedExternsArgs,\n    ...(files.length > 1 ? ['--module_resolution', 'NODE'] : []),\n    ...(commonJs.length ? ['--process_common_js_modules'] : []),\n    ...(wrapper ? ['--output_wrapper', wrapper] : []),\n    '--js', ...files,\n  ]\n  if (jsonFiles.length && !commonJs.length) {\n    const hasRequired = jsonFiles.filter(({ required }) => {\n      return required\n    }, false)\n    if (hasRequired.length) {\n      console.error('You are requiring JSON files. Make sure their relative paths will stay the same to the build.')\n      console.log(hasRequired.map(({ entry, from }) => {\n        return `${c(entry, 'blue')} from ${from.join(' ')}`\n      })\n        .join('\\n'))\n    }\n  }\n  verbose ? console.error(getShellCommand(Args)) : printCommand(args, [\n    ...externs, ...detectedExternsArgs,\n  ], sorted)\n\n  const stdout = await run(Args, runOptions)\n  if (!output) {\n    const o = prepareOutput(stdout, wrapper, noStrict).trim()\n    if (!silent) console.log(o)\n    return o\n  }\n\n  await removeStrict(output, wrapper, noStrict)\n  await makePromise(chmod, [output, '755'])\n  return stdout\n}\n\nconst printCommand = (args, externs, sorted) => {\n  let s = getShellCommand([...args, ...externs])\n  s = replaceWithColor(s, 'js_output_file', 'red')\n  s = replaceWithColor(s, 'externs', 'grey')\n  s = replaceWithColor(s, 'compilation_level', 'green', true)\n  console.error(s)\n  const {\n    commonJs, internals, js, deps,\n  } = sorted\n  const fjs = js.filter(filterNodeModule)\n  const cjs = commonJs.filter(filterNodeModule)\n  if (deps.length) console.error('%s: %s',\n    c('Dependencies', 'yellow'), deps.filter((e, i, a) => {\n      return a.indexOf(e) == i\n    }).join(' '))\n  if (fjs.length) console.error('%s: %s',\n    c('Modules', 'yellow'), fjs.join(' '))\n  if (cjs.length) console.error('%s: %s',\n    c('CommonJS', 'yellow'), cjs.join(' '))\n  if (internals.length) console.error('%s: %s',\n    c('Built-ins', 'yellow'), internals.join(', '))\n}\n\n/**\n * @param {!Array<!_staticAnalysis.Detection>} analysis\n */\nconst warnOfCommonJs = (analysis) => {\n  const res = analysis.map(({ hasMain, name, from }) => {\n    if (!(hasMain && name)) return\n    const fromSrc = from.filter((s) => {\n      const detection = analysis.find(({ entry: e }) => {\n        return e === s\n      })\n      if (!detection) return\n      if (detection.hasMain) return\n      return true\n    })\n    if (!fromSrc.length) return\n    return { name, fromSrc }\n  }).filter(Boolean)\n  if (res.length) {\n    console.error(c(getCompatWarning(), 'red'))\n    console.error('The following commonJS packages referenced in ES6 modules don\\'t support named exports:')\n    res.forEach(({ name, fromSrc }) => {\n      console.error(' %s from %s', c(name, 'red'), c(fromSrc.join(' '), 'grey'))\n    })\n  }\n\n  return res\n}\n\nconst getCompatWarning = () => {\n  let s = `CommonJS don't have named exports, make sure to use them like\n` + `import myModule from 'my-module' /* CommonJS Compat */\nmyModule.default.method('hello world') // yes Node.JS, wat r u doing\nmyModule.default('must explicitly call default')`\n  const mx = s.split('\\n').reduce((acc, { length }) => {\n    if (length > acc) return length\n    return acc\n  }, 0)\n  if (process.stderr.isTTY && mx + 4 < process.stderr.columns) {\n    s = frame(s)\n  }\n  return s\n}\n\nconst filterNodeModule = (entry) => {\n  return !entry.startsWith('node_modules')\n}\n\nconst unique = (e, i, a) => a.indexOf(e) == i\n\n/**\n * Returns compiler arguments to include Node.JS externs.\n * @param {!Array<string>} internals The list of builtin Node.JS modules used.\n * @param {!Array<string>} additional Any extra Node.JS modules to be included\n */\nexport const getNodeExterns = async (internals, additional = []) => {\n  /** @type {function(): string} */\n  const getExternsDir = require(/*ok depack*/'@externs/nodejs')\n  const externsDeps = getExternsDir['dependencies']\n\n  const externsDir = getExternsDir()\n  const allInternals = [...internals, ...additional]\n    .filter(unique)\n    .reduce((acc, i) => {\n      const deps = externsDeps[i] || []\n      return [...acc, i, ...deps]\n    }, [])\n    .filter(unique)\n  const internalExterns = [...allInternals, 'global', 'global/buffer', 'nodejs']\n    .map(i => {\n      if (['module', 'process', 'console', 'crypto'].includes(i)) i = `_${i}`\n      return join(externsDir, `${i}.js`)\n    })\n  await checkExternsExist(internalExterns)\n  const args = createExternsArgs(internalExterns)\n  return args\n}\n\nexport default Compile\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('static-analysis').Detection} _staticAnalysis.Detection\n */\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').CompileConfig} _depack.CompileConfig\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').RunConfig} _depack.RunConfig\n */","export default vm\nexport const {\n  Script,\n  createContext,\n  isContext,\n  runInContext,\n  runInDebugContext,\n  runInNewContext,\n  runInThisContext,\n} = vm","/**\n * The function to extract the position of the symbol from the error due to the fact that the script body couldn't be evaluated by the _vm.Script_ constructor.\n * @param {string} stack The error stack.\n * @param {string} input The input which was passed to the evaluation.\n */\nexport const findPosition = (stack, input) => {\n  const [h, , l2] = stack.split('\\n')\n  const l = parseInt(h.replace(/.+?(\\d+)$/, (m, d) => d)) - 1\n  const c = l2.indexOf('^')\n  const { length } = input.split('\\n').slice(0, l).join('\\n')\n  const lb = length + c + (l ? 1 : 0)\n  return lb\n}","import { Script } from 'vm'\nimport { findPosition } from './lib'\n\n/**\n * Returns the index of the opening `<` symbol in a JSX tag by calling a Script constructor and extracting information from the error message.\n * @param {string} input The string to evaluate in the V8 VM as JavaScript with JSX. If there is no `<`, the `null` is returned. Any another error in code will be thrown as is.\n */\nconst detectJSX = (input) => {\n  try {\n    new Script(input)\n  } catch (err) {\n    const { message, stack } = err\n    if ('Unexpected token <' != message) throw err\n    const bl = findPosition(stack, input)\n    return bl\n  }\n  return null\n}\n\nexport default detectJSX\n\n/* documentary types/index.xml */\n/**\n * @typedef {Object} Config Options for the program.\n * @prop {boolean} [shouldRun=true] A boolean option. Default `true`.\n * @prop {string} text A text to return.\n */\n","export function checkRule(reObject) {\n  if (typeof reObject != 'object') {\n    return false\n  }\n  const { re, replacement } = reObject\n  const hasRe = re instanceof RegExp\n  const type = ['string', 'function'].indexOf(typeof replacement) != -1\n  return hasRe && type\n}\n\nexport const hideStack = (commonError, thrownError) => {\n  if (!(thrownError instanceof Error)) throw thrownError\n  const [, , commonLine] = commonError.stack.split('\\n', 3)\n  const i = thrownError.stack.indexOf(commonLine)\n  if (i == -1) throw thrownError\n  const stack = thrownError.stack.substr(0, i - 1)\n  const li = stack.lastIndexOf('\\n')\n  thrownError.stack = stack.substr(0, li)\n  throw thrownError\n}","import { checkRule, hideStack } from './lib'\n\n/**\n  * _SyncReplaceable_ function receives the whole string and returns the result of transform rules which are either sync function replacers or string replacements (see https://github.com/artdecocode/restream#rule-type for more info). This is not a class and just a function.\n  * @param {string|!Buffer} input The string or buffer to transform synchronously using the replacements. Does not support asynchronous replacements.\n  * @param {!Array<!_restream.Rule>} rules An array with rules.\n  * @return {string}\n  * @example\n```\n// markdown __ to html <em> implementation\nconst stream = SyncReplaceable('__hello world__', {\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n  */\nfunction SyncReplaceable(input, rules) {\n  /**\n   * @suppress {globalThis}\n   */\n  function replace() {\n    const fr = rules.filter(checkRule)\n    const s = fr.reduce((acc, { re, replacement }) => {\n      /** @type {string} */\n      let Acc = acc\n      if (this._broke) return Acc\n\n      if (typeof replacement == 'string') {\n        Acc = Acc.replace(re, replacement)\n        return Acc\n      } else {\n        let commonError\n        const t = Acc.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) return match\n            const p = replacement.call(this, match, ...args)\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        return t\n      }\n    }, `${input}`)\n    return s\n  }\n  replace.brake = () => { replace._broke = true }\n  return replace.call(replace)\n}\n\nexport default SyncReplaceable\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */","import SyncReplaceable from '../SyncReplaceable'\n\n/**\n * @param {string} name\n */\nconst getDefaultRegExp = (name) => {\n  return new RegExp(`%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%`, 'g')\n}\n\n/**\n * Make a unique string to replace cut text with.\n * @param {string} name\n * @param {number} index\n */\nconst getDefaultReplacement = (name, index) => {\n  return `%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%`\n}\n\n/**\n * Create a new marker.\n * @param {string} name The name of the matcher, used in the doc marker.\n * @param {!RegExp} re The regular expression used for detection.\n * @param {!_restream.MakeMarkersConfig} [conf] Additional configuration.\n * @param {function(string, number): string} [conf.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [conf.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @return {!_restream.Marker} The marker.\n */\nconst makeMarker = (name, re, conf) => {\n  const {\n    getReplacement = getDefaultReplacement,\n    getRegex = getDefaultRegExp,\n  } = conf || {}\n  const regExp = getRegex(name)\n  return {\n    name,\n    re,\n    regExp,\n    getReplacement,\n    map: {},\n    lastIndex: 0,\n  }\n}\n\n/**\n * Make markers from a configuration object.\n * @param {!Object.<string, !RegExp>} matchers An object with types of markers to create as keys and their detection regexes as values.\n * @param {!_restream.MakeMarkersConfig} [config] Additional configuration.\n * @param {function(string, number): string} [config.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [config.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @returns {!Object.<string, !_restream.Marker>} An object with markers for each requested type.\n */\nexport const makeMarkers = (matchers, config) => {\n  const res = Object.keys(matchers).reduce((acc, key) => {\n    const re = matchers[key]\n    const marker = makeMarker(key, re, config)\n    const m = {\n      ...acc,\n      [key]: marker,\n    }\n    return m\n  }, {})\n  return res\n}\n\n/**\n * Make a rule for pasting markers back.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @param {!(_restream.Rule|Array<!_restream.Rule>)} [pipeRules] Any additional rules to replace the value of the marker before pasting it.\n * @returns {!_restream.Rule} A rule to paste previously replaced chunks.\n */\nexport const makePasteRule = (marker, pipeRules = []) => {\n  const { regExp: re, map } = marker\n  const rule = {\n    re,\n    replacement(match, index) {\n      const m = map[index]\n      delete map[index]\n      const pr = Array.isArray(pipeRules) ? pipeRules : [pipeRules]\n      const res = SyncReplaceable(m, pr)\n      return res\n    },\n  }\n  return rule\n}\n\n/**\n * Make a rule for initial replacement of markers.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @returns {!_restream.Rule} A rule to cut matched chunks.\n */\nexport const makeCutRule = (marker) => {\n  const { re, map, getReplacement, name } = marker\n  const rule = {\n    re,\n    replacement(match) {\n      const { lastIndex } = marker\n      map[lastIndex] = match\n      marker.lastIndex += 1\n      const m = getReplacement(name, lastIndex)\n      return m\n    },\n  }\n  return rule\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */\n\n/* documentary types/markers.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.Marker} Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @prop {string} name The name of the marker for annotation purposes.\n * @prop {function(string, number): string} getReplacement The function to generate marker placeholders which can be then found, e.g., for (name: `marker`, index: `10`) by default _Restream_ will generate `%%_RESTREAM_MARKER_REPLACEMENT_10_%%`, but can be overriden with this method.\n * @prop {!RegExp} re The regular expression used for detection of the match.\n * @prop {!RegExp} regExp The generated regular expression to replace the marker back to its original value.\n * @prop {!Object<number, string>} map The map which holds detected matches at their indexes.\n * @prop {number} lastIndex The index of the last inserted element. Starts with 0.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.MakeMarkersConfig} MakeMarkersConfig Additional configuration.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.MakeMarkersConfig Additional configuration.\n * @prop {function(string, number): string} [getReplacement] The function used to create a replacement when some text needs to be cut.\n * @prop {function(string): !RegExp} [getRegex] The function used to create a RegExp to detect replaced chunks.\n */\n","import Stream, { Transform } from 'stream'\nimport cleanStack from '@artdeco/clean-stack'\nimport { collect } from 'catchment'\nimport { checkRule, hideStack } from './lib'\n\nexport default class Replaceable extends Transform {\n  /**\n   * Replaceable class that extends Transform and pushes data when it's done replacing each incoming chunk. If the replacement is passed as a function, it will work in the same way as the replacer for `string.replace` method (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), taking the `match` as the first argument, and matched `p1`, `p2`, _etc_ parameters as following arguments. The replacer can also be an async function.\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules A single replacement rule, or multiple rules.\n   * @param {!stream.TransformOptions} [options] The options for the transform stream.\n   * @example\n   *\n```\n// markdown __ to html <em> implementation\nconst stream = replaceStream({\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n   */\n  constructor(rules, options) {\n    super(options)\n    const re = Array.isArray(rules) ? rules : [rules]\n    const fr = re.filter(checkRule)\n    this.rules = fr\n    /**\n     * Whether the _Replaceable_ will not apply any more rules.\n     * @type {boolean}\n     */\n    this._broke = false\n    this._options = options\n  }\n\n  /**\n   * Creates a new replaceable to replace the given string, buffer or stream using the rules of the current stream. Calling `brake` will also set `_broke` on the parent stream.\n   * @param {string|!Buffer|!Stream} input The input to replace.\n   * @param {!Object} [context] The context to assign to the new replaceable.\n   */\n  async replace(input, context) {\n    const replaceable = new Replaceable(this.rules, this._options)\n    if (context) Object.assign(replaceable, context)\n    const res = await Replaceable.replace(replaceable, input)\n    if (replaceable._broke) this.brake()\n    if (context) Object.keys(context).forEach(key => {\n      context[key] = replaceable[key]\n    })\n    return res\n  }\n  /**\n   * The method to end the stream with given data, and collect the result.\n   * @param {!Replaceable} replaceable\n   * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n   */\n  static async replace(replaceable, input) {\n    return replace(replaceable, input)\n  }\n\n  /**\n   * Stop executing further after the current rule.\n   */\n  brake() {\n    this._broke = true\n  }\n\n  /**\n   * @param {string|!Buffer} chunk The incoming chunk, or an object if the stream was started in object mode.\n   */\n  async reduce(chunk) {\n    /** @type {string} */\n    const s = await this.rules.reduce(async (acc, { re, replacement }) => {\n      /** @type {string} */\n      let string = await acc\n      if (this._broke) return string\n\n      if (typeof replacement == 'string') {\n        string = string.replace(re, replacement)\n      } else {\n        const promises = []\n        let commonError\n        const t = string.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) {\n              if (promises.length)\n                return promises.push(Promise.resolve(match))\n              return match\n            }\n            const p = replacement.call(this, match, ...args)\n            if (p instanceof Promise) {\n              promises.push(p)\n            }\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        if (promises.length) {\n          try { // hide stack only for when throw happens before awaits\n            const data = await Promise.all(promises)\n            string = string.replace(re, () => data.shift())\n          } catch (e) {\n            hideStack(commonError, e)\n          }\n        } else {\n          string = t\n        }\n      }\n      return string\n    }, `${chunk}`)\n\n    return s\n  }\n  /**\n   * @suppress {checkTypes}\n   * @returns {!Promise}\n   */\n  async _transform(chunk, _, next) {\n    try {\n      const s = await this.reduce(chunk)\n      this.push(s)\n      next()\n    } catch (e) {\n      const s = cleanStack(e.stack)\n      e.stack = s\n      next(e)\n    }\n  }\n}\n\n/**\n * The method to end the stream with given data, and collect the result.\n * @param {!Replaceable} replaceable\n * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n */\nexport async function replace(replaceable, input) {\n  if (input instanceof Stream) {\n    input.pipe(replaceable)\n  } else {\n    replaceable.end(input)\n  }\n  /** @type {string} */\n  const data = await collect(replaceable)\n  return data\n}\n\n/**\n * The class for when serial execution of asynchronous replacements withing the same rule are needed.\n */\nexport class SerialAsyncReplaceable extends Replaceable {\n  /**\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules\n   */\n  constructor(rules) {\n    super(rules)\n    this.promise = Promise.resolve()\n  }\n  addItem(fn) {\n    const pp = this.promise.then(fn)\n    this.promise = pp\n    return pp\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').AsyncReplacer} _restream.AsyncReplacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Replacer} _restream.Replacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').TransformOptions} stream.TransformOptions\n */","import { SyncReplaceable } from 'restream'\n\n/**\n * Returns the name of the opening tag from the string starting with <, or `undefined`.\n * @param {string} string The string where to find the tag.\n * @example\n * const s = '<div>hello world</div>'\n * const tag = getTagName(s) // div\n */\nexport const getTagName = (string) => {\n  const [, tagName] = /<\\s*(.+?)(?:\\s+[\\s\\S]+)?\\s*\\/?\\s*>/.exec(string) || []\n  return tagName\n}\n\n// * const getClass = o => Object.keys(o).join(' ')\n\n/**\n * Parses a string with attributes written in jsx, e.g., `id={id}` into an object.\n * @param {string} props The string with properties in the tag\n * @example\n *\n * const El = getProps(\"class={'hello world'} id={id}\")\n * // =>\n   {\n     class: \"'hello world'\",\n     id: 'id'\n    }\n *\n */\nexport\nconst getProps = (props) => {\n  let stack = 0\n  const positions = []\n  let current\n  SyncReplaceable(props, [\n    {\n      re: /[{}]/g,\n      replacement(m, i) {\n        const closing = m == '}'\n        const opening = !closing\n        if (!stack && closing)\n          throw new Error('A closing } is found without opening one.')\n        stack += opening ? 1 : -1\n        if (stack == 1 && opening) {\n          current = {\n            open: i,\n          }\n        } else if (stack == 0 && closing) {\n          current.close = i\n          positions.push(current)\n          current = {}\n        }\n      },\n    },\n  ])\n  if (stack) throw new Error(`Unbalanced props (level ${stack}) ${props}`)\n  const obj = {}\n  const destructuring = []\n  const whitespace = {}\n  const lastClose = positions.reduce((acc, { open, close }) => {\n    const before = props.slice(acc, open)\n    const [, wsBefore, propName, wsBeforeAssign, afterAssign] = /(\\s*)(\\S+)(\\s*)=(\\s*)$/.exec(before) || []\n    const val = props.slice(open + 1, close)\n    if (!propName && !/\\s*\\.\\.\\./.test(val))\n      throw new Error('Could not detect prop name')\n    if (!propName) {\n      destructuring.push(val)\n    } else {\n      obj[propName] = val\n    }\n    whitespace[propName] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign }\n    const beforeOrNot = before || '' // when using destructuring\n    const propOrNot = propName || ''\n    const bb = beforeOrNot.slice(0, beforeOrNot.length - propOrNot.length - 1)\n    const { plain, whitespace: ws } = getPlain(bb)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n    return close + 1\n  }, 0)\n  // make sure plain attrs are there when no {} are given\n  if (!positions.length) {\n    const { plain, whitespace: ws } = getPlain(props)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n  } else {\n    const whatsLeft = props.slice(lastClose)\n    const { plain, whitespace: ws } = getPlain(whatsLeft)\n    Object.assign(obj, plain)\n    Object.assign(whitespace, ws)\n  }\n  return { obj, destructuring, whitespace }\n}\n\n/**\n * Returns the matches without {}, such as `id=\"test\"`.\n * @param {string} string The string with plain attributes.\n */\nconst getPlain = (string) => {\n  const r = []\n  const whitespace = {}\n  const res = string.replace(/(\\s*)(\\S+)(\\s*)=(\\s*)([\"'])([\\s\\S]+?)\\5/g, (m, wsBefore, name, wsBeforeAssign, wsAfterAssign, q, val, i) => {\n    whitespace[name] = { before: wsBefore, beforeAssign: wsBeforeAssign, afterAssign: wsAfterAssign }\n    r.push({ i, name, val: `${q}${val}${q}` })\n    return '%'.repeat(m.length)\n  })\n  res.replace(/(\\s*)([^\\s%]+)/g, (m, ws, name, i) => {\n    whitespace[name] = { before: ws }\n    r.push({ i, name, val: 'true' }) // boolean\n  })\n  const obj = [...r.reduce((acc, { i, name, val }) => {\n    acc[i] = [name, val]\n    return acc\n  }, [])].filter(Boolean).reduce((acc, [name, val]) => {\n    acc[name] = val\n    return acc\n  }, {})\n  return { plain: obj, whitespace }\n}\n\n/**\n * Accepts the parsed node properties to make a JS object string out of them.\n * @param {!Object<string, string>} pp The properties out of which to make a string object.\n * @returns {string|null} Either a JS object body string, or null if no keys were in the object.\n */\nexport\nconst makeObjectBody = (pp, destructuring = [], quoteProps = false, whitespace = {}, beforeCloseWs = '') => {\n  const keys = Object.keys(pp)\n  const { length } = keys\n  if (!length && !destructuring.length) return '{}'\n  const pr = `{${keys.reduce((a, k) => {\n    const v = pp[k]\n    const kk = quoteProps || k.indexOf('-') != -1 ? `'${k}'` : k\n    const { before = '', beforeAssign = '', afterAssign = '' } = whitespace[k] || {}\n    return [...a, `${before}${kk}${beforeAssign}:${afterAssign}${v}`]\n  }, destructuring).join(',')}${beforeCloseWs}}`\n  return pr\n}\n\nexport const isComponentName = (tagName = '') => {\n  const [t] = tagName\n  if (!t) throw new Error('No tag name is given')\n  return t.toUpperCase() == t\n}\n\n/**\n * Creates a string invocation of the pragma function.\n * @param {string} tagName The name of the tag to create, or a reference to a component function.\n * @param {!Object<string, string>} props The properties of the element. The properties' values can be passed as strings or references as the `e` function will be called under the scope in which the JSX is written, e.g., when creating components `const C = ({ reference }) => <div id={reference} class=\"String\"/>`.\n * @param {!Array<string>} children The array with the child nodes which are strings, but encode either a reference, a string or an invocation the the `e` function again. Thus the jsx is parsed recursively depth-first.\n * @param {!Array<string>} [destructuring] Any properties for destructuring.\n * @param {boolean} [quoteProps=false] Whether to quote the properties' keys (for Closure compiler).\n * @example\n *\n * const r = pragma('div', { id: \"'STATIC_ID'\" }, [\"'Hello, '\", \"test\", \"'!'\"])\n * // =>\n * e('div',{ id: 'STATIC_ID' },['Hello, ', test, '!'])\n */\nexport const pragma = (tagName, props = {}, children = [], destructuring = [], quoteProps = false, warn = null, whitespace = {}, beforeCloseWs = '') => {\n  const cn = isComponentName(tagName)\n  const tn = cn ? tagName : `'${tagName}'`\n  if (!Object.keys(props).length && !children.length && !destructuring.length) {\n    return `h(${tn})`\n  }\n  const qp = cn && quoteProps == 'dom' ? false : quoteProps\n  if (!cn && destructuring.length && (!quoteProps || quoteProps == 'dom')) {\n    warn && warn(`JSX: destructuring ${destructuring.join(' ')} is used without quoted props on HTML ${tagName}.`)\n  }\n  const pr = makeObjectBody(props, destructuring, qp, whitespace, beforeCloseWs)\n  const c = children.reduce((acc, cc, i) => {\n    const prev = children[i-1]\n    const comma = prev && /\\S/.test(prev) ? ',' : ''\n    return `${acc}${comma}${cc}`\n  }, '')\n  const res = `h(${tn},${pr}${c ? `,${c}` : ''})`\n  return res\n}\n\n// export const newPragma = (tagName, ...args) => {\n//   return `e('${tagName}',${args.join(',')})`\n// }\n\n// * @todo In strict mode, when the length is more, throws an error. In advanced mode, the replacement should be aligned so it is possible to debug it.\n\n/**\n * Replaces a piece of string inside of a string with another chunk.\n * @param {string} input The string inside of which the chunk needs to be replaced.\n * @param {number} index The index of the `<` found with `detect-jsx.findPosition`.\n * @param {number} length The length of the string that needs to be cut out.\n * @param {string} chunk The new string that needs to be placed back into the input.\n *\n */\nexport\nconst replaceChunk = (input, index, length, chunk) => {\n  const before = input.slice(0, index)\n  const after = input.slice(index + length)\n  const ld = length - chunk.length\n  // if (ld < 0)\n  // console.warn('The chunks length is more that replaced input')\n  // throw new Error('The length of the chunk cannot be more than of the replaced value.')\n  let p = chunk\n  if (ld > 0) {\n    p = `${' '.repeat(ld)}${p}`\n  }\n  const res = `${before}${p}${after}`\n  return res\n}","import { SyncReplaceable, makeMarkers, makeCutRule } from 'restream'\nimport { getTagName } from './'\n\nconst findEnding = (string, rules = []) => {\n  let stack = 0\n  let contentEnd\n  const preString = SyncReplaceable(string, [\n    ...rules,\n    {\n      // once the tag is opened with <, its closing symbol > will always be even (nevermind comments & strings)\n      re: /[<>]/g,\n      replacement(m, i) {\n        if (contentEnd) return m\n        const opening = m == '<'\n        const closing = !opening\n        stack += opening ? 1 : -1\n        if (stack == 0 && closing) {\n          contentEnd = i\n        }\n        return m\n      },\n    },\n  ])\n  if (stack) throw new Error(1)\n  return { preString, contentEnd }\n}\n\n/**\n * Returns the outer body of the tag.\n * @param {string} stringWithTag The string in which to find the closing tag. Must start with a `<`.\n */\nconst extract = (stringWithTag) => {\n  const tagName = getTagName(stringWithTag)\n  let contentEnd\n  let props\n  const { arrow } = makeMarkers({\n    arrow: /=>/g,\n  })\n  let preString\n  try {\n    ({ preString, contentEnd } = findEnding(stringWithTag, [ makeCutRule(arrow) ]))\n  } catch (err) {\n    if (err === 1) throw new Error(`Could not find the matching closing > for ${tagName}.`)\n  }\n\n  const string = preString.slice(0, contentEnd + 1)\n  let content = string\n    .replace(/<\\s*[^\\s/>]+/, '')\n  const selfClosing = /\\/\\s*>$/.test(content)\n  if (selfClosing) {\n    props = content.replace(/\\/\\s*>$/, '')\n    content = ''\n    return new ExtractedJSX({\n      string: string.replace(arrow.regExp, '=>'),\n      props: props.replace(arrow.regExp, '=>'),\n      content: '',\n      tagName,\n    })\n  }\n  // now find the corresponding closing tag\n  props = content.replace(/>$/, '')\n  const contentStart = contentEnd + 1\n  contentEnd = false\n  let stack = 1\n  let stringEnd\n  SyncReplaceable(preString, [{\n    // [\\\\s\\\\S] is to not catch the very beginning\n    re: new RegExp(`[\\\\s\\\\S](?:<\\\\s*${tagName}(\\\\s+|>)|/\\\\s*${tagName}\\\\s*>)`, 'g'),\n    replacement(m, opensClosing, i, s) {\n      if (contentEnd) return m\n      const closing = !opensClosing && m.endsWith('>')\n      const opening = !closing\n\n      if (opening) {\n        const untilEnd = s.slice(i)\n        const { contentEnd: ce } = findEnding(untilEnd\n          .replace(/^[\\s\\S]/, ' ')\n          // e.g., <span><a /><span></span></span>\n          //                 ^\n        )\n        const t = untilEnd.slice(0, ce + 1)\n        const tSelfClosing = /\\/\\s*>$/.test(t)\n        if (tSelfClosing) return m\n      }\n\n      stack += opening ? 1 : -1\n      if (stack == 0 && closing) {\n        contentEnd = i\n        stringEnd = contentEnd + m.length\n      }\n      return m\n    },\n  }])\n  if (stack) throw new Error(`Could not find the matching closing </${tagName}>.`)\n  content = preString.slice(contentStart, contentEnd)\n  const string2 = preString.slice(0, stringEnd)\n    .replace(arrow.regExp, '=>')\n\n  return new ExtractedJSX({\n    string: string2,\n    props: props.replace(arrow.regExp, '=>'),\n    content: content.replace(arrow.regExp, '=>'),\n    tagName,\n  })\n}\n\nexport class ExtractedJSX {\n  /**\n   * @param {{ string: string, props: string, content: string, tagName: string }} properties\n   */\n  constructor(properties) {\n    this.string = properties.string\n    this.props = properties.props\n    this.content = properties.content\n    this.tagName = properties.tagName\n  }\n}\n\nexport default extract","import { SyncReplaceable } from 'restream'\nimport extract from './extract'\n\n/**\n * Make a quoted string to interpret by JS.\n * @param {string} s\n * @example\n *\n * getQuoted('The mind always seeks to equilibrium.')\n * // result:\n * `The mind always seeks to equilibrium.`\n */\nexport const getQuoted = (s) => {\n  let _b = '', _a = ''\n  const r = s\n    .replace(/^(\\n\\s*)([\\s\\S]+)?/, (m, b, v = '') => {\n      _b = b\n      return v\n    })\n    .replace(/([\\s\\S]+?)?(\\n\\s*)$/, (m, v = '', a = '') => {\n      _a = a\n      return v\n    })\n  const rr = r ? `\\`${r}\\`` : ''\n  return `${_b}${rr}${_a}`\n}\n\n/**\n * Returns the array of children for an element by extracting the parts in `{}`.\n * @param {string} string\n * @example\n * parseSimpleContent('Hello, {test}!')\n * // result:\n * [`Hello, `, test, `!`]\n */\nexport const parseSimpleContent = (string) => {\n  const temps = []\n  // let prev = 0\n  let current = {}\n  let expressionStack = 0\n  let jsxStack = 0\n  SyncReplaceable(string, [{\n    re: /[<{}]/g,\n    replacement(m, i) {\n      if (i < jsxStack) return // blocked by jsx\n      const isExpression = /[{}]/.test(m)\n      let opening\n      if (isExpression) {\n        opening = m == '{'\n        expressionStack += opening ? 1 : -1\n        if (expressionStack == 1 && current.from == undefined) current.from = i\n        else if (expressionStack == 0) {\n          current.to = i + 1\n          current.expression = string.slice(current.from + 1, i)\n          temps.push(current)\n          current = {}\n        }\n      } else {\n        if (expressionStack) return m\n        const extractedJsx = extract(string.slice(i))\n        jsxStack = i + extractedJsx.string.length\n        current.extractedJsx = extractedJsx\n        current.to = jsxStack\n        current.from = i\n        temps.push(current)\n        current = {}\n      }\n    },\n  }, {\n  }])\n  const res = temps.length ? getTemps(string, temps) : [getQuoted(string)]\n  return res\n}\n\n/**\n * Returns the array with broken down string parts either as other strings or expressions.\n * @param {string} string The initial string.\n * @param {Array<!{from: number, to: number, expression: string }>} temps\n * @return {!Array<string>}\n * @private This is called by parseSimpleContent.\n */\nconst getTemps = (string, temps) => {\n  let lastTo = 0\n  const ar = temps.reduce((acc, { from, to, expression, extractedJsx }) => {\n    const b = string.slice(lastTo, from)\n    if (b) acc.push(getQuoted(b))\n    lastTo = to\n    if (expression) acc.push(expression)\n    else if (extractedJsx) acc.push(extractedJsx)\n    return acc\n  }, [])\n  if (lastTo < string.length) {\n    const a = string.slice(lastTo, string.length)\n    // .trim()\n    if (a) ar.push(getQuoted(a))\n  }\n  return ar\n}","import detectJSX from '@a-la/detect-jsx'\nimport { parseSimpleContent } from './parse-content'\nimport { pragma, replaceChunk, getProps } from './'\nimport extract, { ExtractedJSX } from './extract'\n\n\n/* <div id={'id'}>\n  Hello, {test}! {children}\n  <div class={'TEST'} id={id}>test</div>\n</div> */\n\n/**\n * The entry point to transpiling a file.\n * @param {string} input The string to transpile.\n * @returns {string} The transpiled source code with `h` pragma for hyperscript invocations.\n */\nconst transpileJSX = (input, config = {}) => {\n  const { quoteProps, warn } = config\n  const position = detectJSX(input)\n  if (position === null) return input\n\n  const s = input.slice(position)\n  const { props = '', content, tagName, string: { length } } = extract(s)\n  const children = parseContent(content, quoteProps, warn)\n  const { obj, destructuring, whitespace } = getProps(props.replace(/^ */, ''))\n  const beforeCloseWs = /\\s*$/.exec(props) || ['']\n  const f = pragma(tagName, obj, children, destructuring, quoteProps, warn, whitespace, beforeCloseWs)\n  const res = replaceChunk(input, position, length, f)\n  // find another one one\n  const newRes = transpileJSX(res, config)\n  return newRes\n}\n\nexport default transpileJSX\n\n// let f\n// if (props) {\n//   f = pragma(tagName, prop, children) // `p(tag, { ...props }, children)`\n// } else if (children.length == 1) {\n//   f = pragma(tagName, children[0]) // `e(tag, child)`\n// } else if (children.length) {\n//   f = newPragma(tagName, ...children) // `e(tag, child, child2)`\n// }\n\n// parse the content bro parse it\n/**\n * This function will return an array with content of a jsx tag, and the content can be a function to create an element (pragma), a string, or an expression.\n * @param {string} content\n * @param {boolean} [quoteProps=false] Whether to quote properties.\n */\nexport const parseContent = (content, quoteProps = false, warn = null) => {\n  if (!content) return []\n  // const C = content\n  // .split('\\n').filter(a => !/^\\s*$/.test(a)).join('\\n')\n  const contents = parseSimpleContent(content) // split by expressions\n  const jsx = contents.reduce((acc, string) => {\n    if (string instanceof ExtractedJSX) {\n      const { props = '', content: part, tagName } = string\n      const { obj, destructuring } = getProps(props)\n      const children = parseContent(part, quoteProps, warn)\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\n      return [...acc, p]\n    }\n    const j = detectJSX(string)\n    if (j) {\n      const s = string.slice(j)\n      const { string: { length }, props = '', content: part, tagName } = extract(s)\n      const { obj, destructuring } = getProps(props)\n      const children = parseContent(part, quoteProps, warn)\n      const p = pragma(tagName, obj, children, destructuring, quoteProps, warn)\n      const strBefore = string.slice(0, j)\n      const strAfter = string.slice(j + length)\n      return [...acc, `${strBefore}${p}${strAfter}`]\n    }\n    return [...acc, string]\n  }, [])\n  return jsx\n}","import transpileJSX from './lib/components'\nimport { SyncReplaceable,\n  makeMarkers, makeCutRule, makePasteRule } from 'restream'\n\n/**\n * Process a JSX file.\n * @param {string} input The source code with JSX to transpile.\n * @param {!_alaJsx.Config} config Options for the program.\n * @param {(boolean|string)} [config.quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\n * @param {function(...string)} [config.warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\n */\nconst jsx = (input, config = {}) => {\n  const { e, defObj, ef, i, ias, ii } = makeMarkers({\n    defObj: /^ *export\\s+default\\s+{[\\s\\S]+?}/mg,\n    e: /^ *export\\s+(?:default\\s+)?/mg,\n    ef: /^ *export\\s+{[^}]+}\\s+from\\s+(['\"])(?:.+?)\\1/mg,\n    i: /^ *import(\\s+([^\\s,]+)\\s*,?)?(\\s*{(?:[^}]+)})?\\s+from\\s+['\"].+['\"]/gm,\n    ias: /^ *import\\s+(?:(.+?)\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+['\"].+['\"]/gm,\n    ii: /^ *import\\s+['\"].+['\"]/gm,\n  }, {\n    getReplacement(name, index) {\n      return `/*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%*/`\n    },\n    getRegex(name) {\n      return new RegExp(`/\\\\*%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%\\\\*/`, 'g')\n    },\n  })\n  const s = SyncReplaceable(input, [\n    makeCutRule(ef), makeCutRule(defObj), makeCutRule(e),\n    makeCutRule(i), makeCutRule(ias), makeCutRule(ii)])\n  const tt = transpileJSX(s, config)\n  const as = SyncReplaceable(tt, [\n    makePasteRule(ef), makePasteRule(defObj), makePasteRule(e),\n    makePasteRule(i), makePasteRule(ias), makePasteRule(ii)])\n  return as\n}\n\nexport default jsx\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_alaJsx.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _alaJsx.Config Options for the program.\n * @prop {(boolean|string)} [quoteProps=false] Whether to surround property names with quotes. When the `dom` string is passed, it will only quote props for invoking html components, i.e., those that start with a lowercase letter (E.g., for the _Google Closure Compiler_). Default `false`.\n * @prop {function(...string)} [warn] The function to receive warnings, e.g., when destructuring of properties is used on dom elements (for Closure Compiler).\n */\n","import { Replaceable } from 'restream'\nimport { relative, dirname, join } from 'path'\nimport resolveDependency from 'resolve-dependency'\nimport findPackageJson from 'fpj'\nimport split from '@depack/split'\nimport { checkIfLib, findPackage } from './lib'\n\nexport default class BundleTransform extends Replaceable {\n  /**\n   * @param {string} path Path to the file.\n   * @param {string} to Where the file will be saved.\n   */\n  constructor(path, to) {\n    super([])\n    const replacement = this.replacement.bind(this)\n    this.rules = [\n      {\n        re: /^( *import(?:\\s+[^\\s,]+\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+)['\"](.+)['\"]/gm,\n        replacement,\n      },\n      {\n        re: /^( *import\\s+['\"](.+)['\"])/gm,\n        replacement,\n      },\n      {\n        re: /^( *export\\s+{[^}]+?}\\s+from\\s+)['\"](.+?)['\"]/gm,\n        replacement,\n      },\n    ]\n    this._nodeModules = []\n    this.css = []\n    this._deps = []\n    this.path = path\n    this.to = to\n    this.preactExtern = false\n  }\n  /**\n   * The paths to node_modules in the file.\n   */\n  get nodeModules() {\n    return this._nodeModules\n  }\n  /**\n   * The paths to dependencies.\n   */\n  get deps() {\n    return this._deps\n  }\n  /**\n   * The replacement function that adds extensions to required modules and resolves paths to packages from node_modules.\n   */\n  async replacement(m, pre, from) {\n    const dir = dirname(this.path)\n    if (from.endsWith('.css')) {\n      this.css.push(from)\n      return m\n    }\n    if (checkIfLib(from)) {\n      const { path } = await resolveDependency(from, this.path)\n\n      let relativePath = relative(dir, path)\n\n      if (path.startsWith('..')) {\n        const foundLinked = findPackage(path)\n        if (foundLinked) {\n          const p = join('node_modules', foundLinked)\n          relativePath = relative(dir, p)\n        }\n      }\n      this.deps.push(relativePath)\n\n      const dot = relativePath.startsWith('.') ? '' : './'\n\n      if (m == pre) return pre.replace(/(['\"]).+\\1/, `$1${dot}${replace(relativePath)}$1`)\n      const r = `${pre}'${dot}${replace(relativePath)}'`\n      return r\n    }\n    const { name: n } = split(from)\n    if (n == 'preact' && this.preactExtern) {\n      const { entry } = await findPackageJson(dir, '@externs/preact')\n      this.nodeModules.push(entry)\n      return `${pre}'@externs/preact'`\n    }\n    return m\n    // this is not really doing anything\n    // const { packageJson, entry } = await findPackageJson(dir, n)\n    // if (paths) {\n    //   const d = dirname(packageJson)\n    //   const { path: p } = await resolveDependency(join(d, paths))\n    //   this.nodeModules.push(p)\n    //   const relativePath = relative(this.to, p)\n    //   return `${pre}'${relativePath}'`\n    // }\n    // this.nodeModules.push(entry)\n    // const modRel = relative(this.to, entry)\n    // return `${pre}'${modRel}'`\n  }\n}\n\nconst replace = (string) => {\n  return string.replace(/(\\/index)?\\.js$/, '')\n}","import { dirname, join, resolve } from 'path'\n\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\nexport const findPackage = (entry) => {\n  let p = entry\n  while (p != '.') {\n    p = dirname(p)\n    try {\n      const resolved = resolve(p, 'package.json')\n      const r = require(resolved)\n      const rest = entry.replace(p, '')\n      // require will resolve symlinks\n      const j = join(r['name'], 'package.json')\n      const actualPath = require.resolve(j, {\n        paths: [process.cwd()],\n      })\n      if (resolved == actualPath) {\n        // bingo\n        return join(r['name'], rest)\n      }\n    } catch (err) {\n    /**/}\n  }\n}\n","import { dirname, join, relative, resolve } from 'path'\nimport { read, write, ensurePath } from '@wrote/wrote'\nimport transpileJSX from '@a-la/jsx'\nimport { collect } from 'catchment'\nimport { c } from 'erte'\nimport staticAnalysis from 'static-analysis'\nimport BundleTransform from './BundleTransform'\n\n/**\n * @param {string} entry The path to the file file.\n */\nexport const processFile = async (entry, config, cache) => {\n  const { cachedNodeModules, cachedFiles } = cache\n  const { tempDir, preact, preactExtern } = config\n  const source = await read(entry)\n  const isJSX = entry.endsWith('.jsx')\n\n  const dir = relative('', dirname(entry))\n  const to = join(tempDir, dir)\n  const bt = new BundleTransform(entry, to)\n  bt.preactExtern = preactExtern\n\n  const T = (preact || preactExtern) && isJSX ? addPreact(source, preactExtern) : source\n  bt.end(T)\n  const transformed = await collect(bt)\n  const transpiled = isJSX ? await transpile(transformed, entry): transformed\n  if (entry.startsWith('..')) {\n    // possibly linked package\n    let found\n    let p = entry\n    while (p != '.' && !found) {\n      p = dirname(p)\n      try {\n        const r = require(resolve(p, 'package.json'))\n        const rest = entry.replace(p, '')\n        found = join('node_modules', r['name'], rest)\n      } catch (err) {\n      /**/}\n    }\n    if (!found) console.warn('Entry path %s is above CWD and linked package is not found. The temp file will be generated in %s', entry, join(tempDir, entry))\n    else entry = found\n  }\n  const tto = join(tempDir, entry)\n  await ensurePath(tto)\n\n  await write(tto, transpiled)\n\n  // now deal with dependencies\n  const depPaths = bt.deps\n    .map(d => join(dir, d))\n    .filter(d => !(d in cachedFiles))\n  const nodeModules = bt.nodeModules\n    .filter(d => !(d in cachedNodeModules))\n\n  nodeModules.forEach(nm => { cachedNodeModules[nm] = 1 })\n  depPaths.forEach(dp => { cachedFiles[dp] = 1 })\n\n  // add node modules\n  const sa = await staticAnalysis(nodeModules)\n  sa.forEach(({ entry: e, packageJson }) => {\n    if (packageJson) cachedNodeModules[packageJson] = 1\n    cachedNodeModules[e] = 1\n  })\n\n  await bt.css.reduce(async (acc, css) => {\n    await acc\n    const path = join(dir, css)\n    const file = await read(path)\n    const text = `import injectStyle from 'depack/inject-css'\n\ninjectStyle(\\`${file}\\`)`\n    const cssTo = join(to, `${css}.js`)\n    await write(cssTo, text)\n  }, {})\n\n  await depPaths.reduce(async (acc, depPath) => {\n    await acc\n    await processFile(depPath, config, cache)\n  }, {})\n}\n\nconst addPreact = (source, preactExtern) => {\n  const t = preactExtern ? '@externs/preact' : 'preact'\n  return `import { h } from '${t}'\n${source}`\n}\n\nconst transpile = async (source, entry) => {\n  return await transpileJSX(source, {\n    quoteProps: 'dom',\n    warn(message) {\n      console.warn(c(message, 'yellow'))\n      console.log(entry)\n    },\n  })\n}","import { processFile } from './lib'\nimport { join, relative } from 'path'\n\n/**\n * Generates a temp directory for the given entry file and transpiles JSX files. Returns the list of all dependencies including in the `node_modules`.\n * @param {string} entry The path to the entry file.\n * @param {!_depack.TempConfig} [config] Options for generating the temp directory.\n * @param {string} [config.tempDir=\"depack-temp\"] The directory in which to place temp files. Default `depack-temp`.\n * @param {boolean} [config.preact=false] Whether to add `import { h } from 'preact'` automatically at the top of each JSX file. Default `false`.\n * @param {boolean} [config.preactExtern=false] Whether to add `import { h } from '\uff20externs/preact'` automatically at the top of each JSX file, and rename preact imports into `\uff20externs/preact` imports. See https://www.npmjs.com/package/\uff20externs/preact. Default `false`.\n */\nconst generateTemp = async (entry, config = {}) => {\n  const {\n    tempDir = 'depack-temp',\n    preact,\n    preactExtern,\n  } = config\n  const cache = {\n    cachedFiles: {\n      [relative('', entry)]: 1,\n    },\n    cachedNodeModules: {},\n  }\n  await processFile(entry, {\n    tempDir, preact, preactExtern,\n  }, cache)\n  const tempFiles = Object.keys(cache.cachedFiles)\n    .map(f => join(tempDir, f))\n  return [...tempFiles, ...Object.keys(cache.cachedNodeModules)]\n}\n\nexport default generateTemp\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_depack.TempConfig} TempConfig Options for generating the temp directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _depack.TempConfig Options for generating the temp directory.\n * @prop {string} [tempDir=\"depack-temp\"] The directory in which to place temp files. Default `depack-temp`.\n * @prop {boolean} [preact=false] Whether to add `import { h } from 'preact'` automatically at the top of each JSX file. Default `false`.\n * @prop {boolean} [preactExtern=false] Whether to add `import { h } from '\uff20externs/preact'` automatically at the top of each JSX file, and rename preact imports into `\uff20externs/preact` imports. See https://www.npmjs.com/package/\uff20externs/preact. Default `false`.\n */\n","import { rm } from '@wrote/wrote'\nimport generateTemp from '@depack/bundle'\nimport { join, relative } from 'path'\nimport staticAnalysis, { sort } from 'static-analysis'\nimport { getCommand, updateSourceMaps, hasJsonFiles, createExternsArgs, detectExterns, getBundleArgs } from './'\nimport run from './run'\n\n/**\n * @param {string|!Array<string>} src The path or paths to the entries.\n * @param {boolean} [needsAnalysis] Whether the shallow analysis result needs to be returned.\n */\nexport const doesSrcHaveJsx = async (src, needsAnalysis) => {\n  if (!needsAnalysis && Array.isArray(src)) {\n    if (src.some(endsWithJsx)) return { hasJsx: true }\n  } else if (!needsAnalysis && endsWithJsx(src)) return { hasJsx: true }\n\n  const analysis = await staticAnalysis(src, { shallow: true })\n  const hasJsx = analysis.some(({ entry, name }) => {\n    if (name) return false // return node_modules\n    return endsWithJsx(entry)\n  })\n  return { hasJsx, analysis }\n}\nconst endsWithJsx = (name) => {\n  return name.endsWith('.jsx')\n}\n\n/**\n * Create the temp dir.\n */\nexport const prepareTemp = async (src, { tempDir, preact, preactExtern, forceTemp }) => {\n  let Src = src\n  if (forceTemp) {\n    await generateTemp(src, { tempDir, preact, preactExtern })\n    Src = join(tempDir, src)\n    return { Src, hasJsx: true }\n  }\n  const { hasJsx, analysis } = await doesSrcHaveJsx(src)\n  if (hasJsx) {\n    await generateTemp(src, { tempDir, preact, preactExtern })\n    Src = join(tempDir, src)\n  }\n  return { Src, hasJsx, analysis }\n}\n\n/**\n * Bundle the source code.\n * @param {_depack.BundleConfig} options Options for the web bundler.\n * @param {_depack.RunConfig} [runOptions] General options for running of the compiler.\n * @param {!Array<string>} [compilerArgs] Extra arguments for the compiler, including the ones got with `getOptions`.\n */\nconst Bundle = async (options, runOptions = {}, compilerArgs = []) => {\n  const { src, tempDir = 'depack-temp', preact, preactExtern, silent } = options\n  const { output, compilerVersion, debug, noSourceMap } = runOptions\n  if (!src) throw new Error('Entry file is not given.')\n\n  let deps\n  let processCommonJs\n  let { Src, hasJsx } = await prepareTemp(src, { tempDir, preact, preactExtern })\n\n  const detected = await staticAnalysis(Src, {\n    fields: ['externs'],\n  })\n\n  const { files: detectedExterns } = await detectExterns(detected)\n  const externs = createExternsArgs(detectedExterns)\n\n  const sorted = sort(detected)\n  const {\n    commonJs, commonJsPackageJsons, js, packageJsons,\n  } = sorted\n  const jsonFiles = hasJsonFiles(detected)\n  processCommonJs = Boolean(commonJs.length || jsonFiles.length)\n  deps = [Src, ...commonJs, ...packageJsons,\n    ...js,\n    ...commonJsPackageJsons]\n\n  let sigint = false\n  const getSigInt = () => {\n    return sigint\n  }\n  // process.on('SIGINT', () => {\n  //   sigint = true\n  // })\n  const PreArgs = getBundleArgs(compilerArgs, externs, output, noSourceMap, deps, processCommonJs)\n\n  const jjs = hasJsx ? deps.map((j) => {\n    return j.startsWith(tempDir) ? relative(tempDir, j) : j\n  }) : deps\n  const a = getCommand(PreArgs, jjs)\n  console.error(a)\n  const Args = [...PreArgs, '--js', ...deps]\n\n  const stdout = await run(Args, { debug, compilerVersion, output,\n    noSourceMap, getSigInt })\n  if (!output && stdout && !silent) console.log(stdout)\n  if (hasJsx) {\n    if (!sigint && output && !noSourceMap)\n      await updateSourceMaps(output, tempDir)\n    await rm(tempDir)\n  }\n  return stdout\n}\n\nexport default Bundle\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').BundleConfig} _depack.BundleConfig\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').RunConfig} _depack.RunConfig\n */","import { join, basename, relative, sep } from 'path'\nimport { rm } from '@wrote/wrote'\nimport staticAnalysis, { sort } from 'static-analysis'\nimport { getBundleArgs, updateTempDirArgs, getCommand, unique, createExternsArgs, hasJsonFiles, detectExterns, updateSourceMaps } from './'\nimport run from './run'\nimport { prepareTemp, doesSrcHaveJsx } from './bundle'\n\n/**\n * Bundle the source code into chunks.\n * @param {_depack.ChunksConfig} options Options for the web bundler.\n * @param {_depack.RunConfig} [runOptions] General options for running of the compiler.\n * @param {!Array<string>} [compilerArgs] Extra arguments for the compiler, including the ones got with `getOptions`.\n */\nexport default async function BundleChunks(options, runOptions, compilerArgs = []) {\n  const { srcs, tempDir = 'depack-temp', preact, preactExtern, checkCache,\n    rel } = options\n  const { output = '', compilerVersion, debug, noSourceMap } = runOptions\n  if (!srcs) throw new Error('Entry files are not given.')\n  if (!Array.isArray(srcs)) throw new Error('Expecting an array of source files to generate chunks.')\n\n  let deps = []\n  let processCommonJs = false\n  let { hasJsx, analysis } = await doesSrcHaveJsx(srcs, true)\n  if (checkCache) {\n    const res = await checkCache(analysis)\n    if (res) return\n  }\n  // If one has jsx, create temp for all.\n  // @depack/bundle needs updating to reference src JS files and create\n  // temp only for JSX.\n  let detectedExterns = []\n  // const chunks = []\n\n  const chunksMap = {}\n  // a map where source name is key and its dependencies are value\n  const map = await srcs.reduce(async (acc, src) => {\n    acc = await acc\n    const { Src } = await prepareTemp(src, { tempDir, preact, preactExtern, forceTemp: hasJsx })\n\n    const detected = await staticAnalysis(Src, {\n      fields: ['externs'],\n    })\n\n    const { files: de } = await detectExterns(detected)\n    detectedExterns = [...detectedExterns, ...de]\n\n    const sorted = sort(detected)\n    const {\n      commonJs, commonJsPackageJsons, js, packageJsons,\n    } = sorted\n\n    const jsonFiles = hasJsonFiles(detected)\n    processCommonJs = processCommonJs || Boolean(commonJs.length || jsonFiles.length)\n\n    const sd = [...commonJs, ...packageJsons, ...js, ...commonJsPackageJsons]\n    deps = [...deps, ...sd]\n\n    acc[Src] = sd\n    return acc\n  }, {})\n\n  const depsMap = deps.reduce((acc, current) => {\n    if (!acc[current]) acc[current] = 1\n    else acc[current]++\n    return acc\n  }, {})\n  const commonChunk = Object.entries(depsMap).reduce((acc, [key, value]) => {\n    if (value > 1) {\n      acc.push('--js', key)\n      // commonChunk['common'] = join(output, 'common.js')\n    }\n    return acc\n  }, [])\n\n  const outputFiles = []\n  if (commonChunk.length) {\n    commonChunk.push('--chunk', `common:${commonChunk.length/2}`)\n    // 'common:auto')\n    outputFiles.push(join(output, 'common.js'))\n  }\n  const Rel = hasJsx && rel ? join(tempDir, rel) : rel\n  const chunks = Object.entries(map).reduce((acc, [key, value]) => {\n    const chunkDeps = value.filter(v => depsMap[v] == 1)\n    const c = chunkDeps.reduce(addJsArg, [])\n    const n = Rel ? relative(Rel, key) : basename(key)\n    const name = n.replace(/.jsx$/, '.js').replace(sep, '-')\n    const cu = [name.replace('.js', ''), chunkDeps.length + 1]\n    if (chunkDeps.length != value.length) {\n      chunksMap[name] = ['common']\n      cu.push('common')\n    }\n    acc.push(...c, '--js', key, '--chunk', cu.join(':'))\n    const file = join(output, name)\n    outputFiles.push(file)\n    return acc\n  }, [])\n\n  const externs = createExternsArgs(detectedExterns.filter(unique))\n\n  const PreArgs = getBundleArgs(compilerArgs, externs, output, noSourceMap, deps, processCommonJs)\n  // const jjs = hasJsx ?\n  const depsAndChunks = [...commonChunk, ...chunks]\n  const a = getCommand(PreArgs, updateTempDirArgs(depsAndChunks, tempDir))\n  console.error(a)\n  const Args = [...PreArgs, ...depsAndChunks]\n\n  const stdout = await run(Args, { debug, compilerVersion, output,\n    noSourceMap, outputFiles })\n  if (!output && stdout) console.log(stdout)\n\n  if (hasJsx) {\n    if (output && !noSourceMap)\n      await Promise.all(outputFiles.map(async (o) => {\n        await updateSourceMaps(o, tempDir)\n      }))\n    await rm(tempDir)\n  }\n  return chunksMap\n}\n\nexport const addJsArg = (a, v) => [...a, '--js', v]\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').ChunksConfig} _depack.ChunksConfig\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').RunConfig} _depack.RunConfig\n */","import { read } from '@wrote/wrote'\n\nexport { default as Compile } from './lib/compile'\nexport { default as Bundle } from './lib/bundle'\nexport { default as BundleChunks } from './lib/chunks'\nexport { default as run } from './lib/run'\nexport { default as getOptions, getOutput } from './lib/get-options'\n\n/**\n * If the `GOOGLE_CLOSURE_COMPILER` was set using the environment variable, it will be returned in this named exported.\n */\nconst GOOGLE_CLOSURE_COMPILER = process.env['GOOGLE_CLOSURE_COMPILER']\n\nexport { GOOGLE_CLOSURE_COMPILER }\n\n/**\n * If `GOOGLE_CLOSURE_COMPILER` was set using an environment variable, returns `target`, otherwise reads the version from the `google-closure-compiler-java` package.json file.\n */\nexport const getCompilerVersion = async () => {\n  /** @type {string} */\n  let compilerVersion = 'target'\n  const compilerPackage = GOOGLE_CLOSURE_COMPILER ? 'target' : require.resolve('google-closure-compiler-java/package.json')\n\n  if (!GOOGLE_CLOSURE_COMPILER) {\n    const compilerPackageJson = await read(compilerPackage)\n    const { 'version': cv } = JSON.parse(compilerPackageJson)\n    ;[compilerVersion] = cv.split('.')\n  }\n  return compilerVersion\n}","/**\n * @license\n * @depack/depack: Depack Node.JS API for Closure Compiler execution.\n *\n * Copyright (C) 2019 Art Deco\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nimport '../types/externs'\nimport { Compile, Bundle, BundleChunks, run, getOptions, getOutput, getCompilerVersion, GOOGLE_CLOSURE_COMPILER } from './'\n\nmodule.exports = {\n  '_Compile': Compile,\n  '_Bundle': Bundle,\n  '_BundleChunks': BundleChunks,\n  '_run': run,\n  '_getOptions': getOptions,\n  '_getOutput': getOutput,\n  '_getCompilerVersion': getCompilerVersion,\n  '_GOOGLE_CLOSURE_COMPILER': GOOGLE_CLOSURE_COMPILER,\n}","import { join, basename, sep } from 'path'\n\nconst getLanguage = (l) => {\n  if (/^\\d+$/.test(l)) return `ECMASCRIPT_${l}`\n  return l\n}\n\n/**\n * Returns the arguments for the compiler.\n * @param {!_depack.GetOptions} [opts] Parameters for `getOptions`. https://github.com/google/closure-compiler/wiki/Flags-and-Options\n */\nconst getOptions = (opts = {}) => {\n  const {\n    compiler = require.resolve('google-closure-compiler-java/compiler.jar'),\n    output, level, advanced, languageIn, languageOut, sourceMap = true,\n    argv = [], prettyPrint, noWarnings, debug, iife, chunkOutput,\n  } = opts\n  /** @type {!Array<string>} */\n  const options = ['-jar', compiler]\n  if (level) {\n    options.push('--compilation_level', level)\n  } else if (advanced) {\n    options.push('--compilation_level', 'ADVANCED')\n  }\n  if (languageIn) {\n    const lang = getLanguage(languageIn)\n    options.push('--language_in', lang)\n  }\n  if (languageOut) {\n    const lang = getLanguage(languageOut)\n    options.push('--language_out', lang)\n  }\n  if ((output || chunkOutput) && sourceMap && !debug) {\n    options.push('--create_source_map', '%outname%.map',\n      // '--source_map_include_content'\n    )\n  }\n  if (prettyPrint) {\n    options.push('--formatting', 'PRETTY_PRINT')\n  }\n  if (debug) {\n    options.push('--print_source_after_each_pass')\n  }\n  if (iife) {\n    options.push('--isolation_mode', 'IIFE')\n  }\n  if (noWarnings || debug) {\n    options.push('--warning_level', 'QUIET')\n  }\n  options.push(...argv)\n  if (output) {\n    options.push('--js_output_file', output)\n  }\n  if (chunkOutput) {\n    options.push('--chunk_output_path_prefix', join(chunkOutput, sep))\n  }\n  return options\n}\n\n/**\n * Returns the location of the output file, even when the directory is given.\n * @param {string} output\n * @param {string} src\n */\nexport const getOutput = (output, src) => {\n  let o = /\\.js$/.test(output) ? output : join(output, basename(src))\n  o = o.replace(/jsx$/, 'js')\n  return o\n}\n\nexport default getOptions\n\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../../compile').GetOptions} _depack.GetOptions\n */"],
"names":["chmod","fs","createReadStream","createWriteStream","lstat","mkdir","readdir","rmdir","unlink","$jscompDefaultExport","stream","Transform","Writable","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","read","path","write","data","ws","err","end","checkArgumentIndex","i","makePromise","fn","resolveValue","fnLength","resolve","reject","error","allArgs","Array","isArray","forEach","arg","basename","dirname","relative","sep","ensurePath","dir","make","code","parentDir","lstatFiles","dirPath","dirContent","readFiles","relativePath","ls","all","isDirectory","lstatRes","isNotDirectory","readDirStructure","ignore","lsr","directories","files","notDirectories","reduce","acc","current","isFile","isSymbolicLink","type","dirs","rel","structure","content","removeFile","removeDir","keys","k","filesFullPaths","file","dirsFullPaths","rm","s","exists","colors","backgroundColors","c","string","color","cc","b","builtinModules","_module","resolveDependency","relativeFrom","isDir","checkSources","fileChecked","fileRes","endsWith","startsWith","pp","mismatch","o","p","capturedGroup","key","start","RE","RE2","RE3","RE4","getMatches","a","scope","name","paths","findPackageJson","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","f","mod","JSON","parse","resolved","indexExists","checkIfLib","modName","getDependenciesMeta","matches","pckg","proms","internal","isLib","package","n","console","warn","Boolean","detect","cache","nodeModules","shallow","node_modules_cache","mergeSameNodeModules","requireMatches","getRequireMatches","fm","fr","dm","val","required","deps","Deps","existing","discovered","entries","accRes","staticAnalysis","config","detected","filtered","findIndex","fi","ii","ei","ee","ff","froms","el","newF","props","sort","packageJsons","commonJsPackageJsons","commonJs","js","internals","pad","width","repeat","Math","max","paddys","w","l","bind","frameOfMind","padding","ww","bt","bb","line","replaceWithColor","str","background","bef","getCommand","getShellCommand","jss","addData","sourceMap","rr","removeStrict","wrapper","noStrict","prepared","prepareOutput","output","wp","actualOutput","hasUseStrict","ao","aw","updateSourceMaps","tempDir","newSources","sources","jj","stringify","getWrapper","hasJsonFiles","DEPACK_MAX_COLUMNS","process","env","maxLength","stderr","columns","lastLineLength","program","checkExternsExist","exist","detectExterns","nodeJS","externs","actual","createExternsArgs","unique","updateTempDirArgs","getBundleArgs","compilerArgs","noSourceMap","processCommonJs","makeError","exitCode","se","t","getCoreVersion","VER","V","log","prepareCoreModules","nodeModulesPath","force","corePath","require","getCorePath","index","ret","depackExist","testDepack","core","testPackage","depack","fixDependencies","commonJS","modules","dep","field","M","newM","relPath","$indicatrix","text","interval","writable","stdout","placeholder","int","setInterval","clearInterval","spawn","child_process","getPromise","proc","spawnCommand","command","run","debug","compilerVersion","outputFiles","compilerStderr","outputFile","printCommand","sorted","fjs","filterNodeModule","cjs","warnOfCommonJs","analysis","fromSrc","detection","find","getCompatWarning","mx","isTTY","frame","getNodeExterns","additional","getExternsDir","externsDeps","externsDir","internalExterns","allInternals","Script","vm","findPosition","input","h","l2","parseInt","detectJSX","bl","checkRule","reObject","hasRe","replacement","hideStack","commonError","thrownError","commonLine","substr","li","lastIndexOf","SyncReplaceable","rules","_broke","Acc","call","brake","replace.brake","getDefaultRegExp","toUpperCase","getDefaultReplacement","makeMarkers","matchers","getReplacement","getRegex","regExp","lastIndex","marker","makePasteRule","pipeRules","rule","pr","makeCutRule","replaceable","Replaceable","_options","context","Replaceable$$module$node_modules$restream$src$Replaceable.replace","promises","shift","next","Stream","getTagName","tagName","exec","getProps","positions","closing","opening","open","close","obj","destructuring","whitespace","lastClose","before","wsBefore","propName","wsBeforeAssign","afterAssign","beforeAssign","beforeOrNot","plain","getPlain","whatsLeft","wsAfterAssign","q","makeObjectBody","quoteProps","beforeCloseWs","v","kk","isComponentName","pragma","children","cn","tn","qp","prev","comma","findEnding","contentEnd","preString","extract","stringWithTag","arrow","selfClosing","ExtractedJSX","contentStart","stringEnd","opensClosing","untilEnd","ce","tSelfClosing","string2","getQuoted","_b","_a","parseSimpleContent","temps","expressionStack","jsxStack","isExpression","to","expression","extractedJsx","getTemps","lastTo","ar","transpileJSX","position","parseContent","after","ld","newRes","contents","jsx","part","strBefore","strAfter","defObj","ef","ias","tt","as","BundleTransform","_nodeModules","css","_deps","preactExtern","pre","actualPath","cwd","foundLinked","dot","processFile","cachedNodeModules","cachedFiles","preact","isJSX","T","transformed","transpiled","transpile","found","tto","depPaths","nm","dp","sa","cssTo","depPath","generateTemp","tempFiles","doesSrcHaveJsx","src","needsAnalysis","some","endsWithJsx","hasJsx","prepareTemp","forceTemp","Src","addJsArg","GOOGLE_CLOSURE_COMPILER","module","exports","Compile","runOptions","verbose","silent","foundAdditional","realCompilerArgs","detectedExterns","detectedExternsArgs","internalDeps","jsonFiles","Args","hasRequired","Bundle","PreArgs","jjs","getSigInt","sigint","BundleChunks","srcs","checkCache","chunksMap","de","sd","depsMap","commonChunk","value","Rel","chunks","chunkDeps","cu","depsAndChunks","getOptions","compiler","level","advanced","languageIn","languageOut","argv","prettyPrint","noWarnings","iife","chunkOutput","lang","getOutput","getCompilerVersion","compilerPackage","compilerPackageJson","cv"]
}
